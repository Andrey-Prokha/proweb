<!DOCTYPE html>
<html class="page" lang="ru">

<head>
  <meta charset="utf-8">
  <title>PHP Строки</title>
  <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body class="page__body">

  <section class="modal">
    <div class="modal__wrapper">
      <div class="modal__block">
        <h3 class="modal__title">Размер шрифта:</h3>
        <button type="button" class="button button--accessibility fontsize-standart"
          title="Стандартный размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-2x"
          title="Увелеченный дважды размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-4x"
          title="Увелеченный четырежды размер шрифта">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Цвет сайта:</h3>
        <button type="button" class="button button--accessibility color-whiteblack" title="Бело-черный стиль">А</button>
        <button type="button" class="button button--accessibility color-blackwhite" title="Черно-белый стиль">А</button>
        <button type="button" class="button button--accessibility color-blue" title="Сине-голубой стиль">А</button>
        <button type="button" class="button button--accessibility color-standart" title="Стандартный стиль">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Изображения:</h3>
        <button type="button" class="button button--accessibility image-off" title="Отключить изображение"><span
            class="visually-hidden">Выкл.</span></button>
        <button type="button" class="button button--accessibility image-on" title="Включить изображение"><span
            class="visually-hidden">Вкл.</span><svg class="image__svg" version="1.1" xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 350 350">
            <path
              d="M5,350h340V0H5V350z M25,330v-62.212h300V330H25z M179.509,247.494H60.491L120,171.253L179.509,247.494z   M176.443,211.061l33.683-32.323l74.654,69.05h-79.67L176.443,211.061z M325,96.574c-6.384,2.269-13.085,3.426-20,3.426  c-33.084,0-60-26.916-60-60c0-6.911,1.156-13.612,3.422-20H325V96.574z M25,20h202.516C225.845,26.479,225,33.166,225,40  c0,44.112,35.888,80,80,80c6.837,0,13.523-0.846,20-2.518v130.306h-10.767l-104.359-96.526l-45.801,43.951L120,138.748  l-85.109,109.04H25V20z" />
          </svg></button>
      </div>
    </div>
  </section>

  <button type="button" class="accessibility" title="Открыть панель доступности"><svg width="50" height="50"
      viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
      <path class="accessibility__svg"
        d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
      </path>
    </svg></button>
  <div class="page__wrapper">

    <header class="header">

      <nav class="nav">
        <ul class="nav__list">
          <li class="nav__item">
            <a class="nav__link" href="../../index.html">Главная</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../lectures.html">Лекции</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../video.html">Видео-уроки</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../practical.html">Лабораторные работы</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../tests.html">Тесты</a>
          </li>
        </ul>
      </nav>

    </header>

    <main class="content">
      <h1 class="content__title">Строки</h1>
      <h2>Управляющие последовательности</h2>
      <p>Если строка заключена в двойные кавычки ("), PHP распознает
        большее количество управляющих последовательностей для
        специальных символов:
      </p>
      <table class="table">
        <caption><strong>Управляющие последовательности</strong></caption>
        <thead>
          <tr class="table__row">
            <th>Последовательность</th>
            <th>Значение</th>
          </tr>
        </thead>
        <tbody>
          <tr class="table__row">
            <td class="table__cell"><em>\n</em></td>
            <td class="table__cell">новая строка (LF или 0x0A (10) в ASCII)</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\r</em></td>
            <td class="table__cell">возврат каретки (CR или 0x0D (13) в ASCII)</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\t</em></td>
            <td class="table__cell">горизонтальная табуляция (HT или 0x09 (9) в ASCII)</td>
          </tr>

          <tr class="table__row">
            <td class="table__cell"><em>\v</em></td>
            <td class="table__cell">вертикальная табуляция (VT или 0x0B (11) в ASCII) (с версии PHP 5.2.5)</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\e</em></td>
            <td class="table__cell">escape-знак (ESC или 0x1B (27) в ASCII) (с версии PHP 5.4.4)</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\f</em></td>
            <td class="table__cell">подача страницы (FF или 0x0C (12) в ASCII) (с версии PHP 5.2.5)</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\\</em></td>
            <td class="table__cell">обратная косая черта</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\$</em></td>
            <td class="table__cell">знак доллара</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\"</em></td>
            <td class="table__cell">двойная кавычка</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\[0-7]{1,3}</em></td>
            <td class="table__cell">
              последовательность символов, соответствующая
              регулярному выражению символа в восьмеричной
              системе счисления
            </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell"><em>\x[0-9A-Fa-f]{1,2}</em></td>
            <td class="table__cell">
              последовательность символов, соответствующая
              регулярному выражению символа в шестнадцатеричной
              системе счисления
            </td>
          </tr>
        </tbody>
      </table>

      <h2>Манипулирование строками</h2>
      <p>Для работы со строками в PHP существует целый ряд специализированных
        функций.

      </p>
      <h2>Форматирование строк</h2>
      <p>В PHP есть две функции, позволяющие отформатировать данные перед выводом:
      </p>
      <ul>
        <li><b>printf()</a></b> - выводит отформатированную строку в окно браузера;
        </li>
        <li><b>sprintf()</a></b> - выводит отформатированную строку в переменную.<br>
          Далее можно использовать для записи в файл с помощью функции <b>fputs()</a></b>.
        </li>
      </ul>
      <p>Этим функциям передаются строка управления форматом и сами форматируемые
        данные. Строка управления форматом включает в себя обычные символы, которые
        прямо копируются в результат, и определители преобразования. Каждый
        определитель преобразования начинается с символа процента (<b>%</b>) и
        включает следующие элементы:
      </p>
      <ul>
        <li><b>указатель заполнения</b> используется, если необходимо
          увеличить размер строки. По умолчанию выполняется заполнение пробелами.
          Можно указать и 0. Перед любым другим символом заполнения надо поставить
          одинарную кавычку (<b>'</b>). Необязательный параметр;
        </li>
        <li><b>указатель выравнивания</b>, заданный знаком минус (<b>-</b>),
          определяет выравнивание влево. По умолчанию выполняется выравнивание вправо.
          Необязательный параметр;
        </li>
        <li><b>указатель ширины</b> задает количество символов, которое должно
          содержаться в выводимых данных. Необязательный параметр;
        </li>
        <li><b>указатель точности</b> задает количество десятичных знаков,
          отображаемых для чисел с плавающей запятой. Необязательный параметр;
        </li>
        <li><b>указатель типа</b> задает тип, в соответствии с которым следует
          обрабатывать выводимые данные. Возможные значения:
          <table class="table">
            <colgroup>
              <col>
            </colgroup>
            <tbody>
              <tr class="table__row">
                <td class="table__cell">d</td>
                <td class="table__cell">десятичное число
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">b</td>
                <td class="table__cell">двоичное число
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">c</td>
                <td class="table__cell">ASCII-эквивалент
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">f</td>
                <td class="table__cell">число с плавающей точкой двойной точности
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">o</td>
                <td class="table__cell">восьмеричное число
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">s</td>
                <td class="table__cell">строка
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">x</td>
                <td class="table__cell">шестнадцатеричное число в нижнем регистре
                </td>
              </tr>
              <tr class="table__row">
                <td class="table__cell">X</td>
                <td class="table__cell">шестнадцатеричное число в верхнем регистре
                </td>
              </tr>
            </tbody>
          </table>
        </li>
      </ul>
      <h4>Пример 1</h4>
      <pre class="code">&lt;html&gt;
  &lt;head&gt;
  &lt;title&gt;Форматирование вывода в окно браузера&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;?php
  $товары = array ("помидоры" =&gt; 15, "огурцы" =&gt; 12, "картофель" =&gt; 10);
  echo  "&lt;pre&gt;";
  printf ("%-25s%25s\n%'=50s\n", "Наименование", "Цена", "");
  foreach ($товары as $наим =&gt; $цена)
    printf ("%'.-25s%'.22.2f\n", $наим, $цена);
  echo  "&lt;/pre&gt;";
  ?&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre>

      <h2>Анализ строк</h2>
      <p>PHP содержит множество функций, дающих информацию о строках.
        Наиболее употребимыми являются:
      </p>
      <ul>
        <li><b>strlen()</b> - определяет длину строки.
        </li>
        <li><b>strstr()</b> - определяет наличие подстроки в строке. Аргументы:
          исходная строка и искомая подстрока. Если такой подстроки в строке нет, функция
          возвращает false. Если подстрока в строке есть, функция
          возвращает часть исходной строки, которая начинается с искомой подстроки.
          <pre class="code">echo strstr ("Кто там?", "там"); // выводит "там?"</pre>
        </li>
        <li><b>stristr()</b> - работает так же, как иstrstr(), но не
          различает регистры.
        </li>
        <li><b>strpos()</b> - определяет позицию подстроки в строке. Аргументы:
          исходная строка и искомая подстрока. Если такой подстроки в строке нет, функция
          возвращаетfalse. Если подстрока в строке есть, функция
          возвращает номер символа, с которого начинается подстрока.
          <pre class="code">echo strpos ("Кто там?", "там"); // выводит "4"</pre>
        </li>
        <li><b>substr()</b> - возвращает часть строки, ограниченную параметрами.
          Аргументы: исходная строка, начальная позиция, длина подстроки (необязательно).
          Если начальная позиция отрицательна, то отсчет идет от конца строки.
          Если длина не указана, возвращается остаток строки.
          Если длина отрицательна, то подстрока завершается на указанной
          позиции от конца строки.
          <pre class="code">echo substr ("раз-два-три", 4, 3);  // выводит "два"
  echo substr ("раз-два-три", 4);     // выводит "два-три"
  echo substr ("раз-два-три", -3, 3); // выводит "три"
  echo substr ("раз-два-три", 4, -3); // выводит "два-"</pre>
        </li>
      </ul>

      <h2>Управление строками</h2>
      <p>PHP содержит множество функций управления строками.
        Наиболее употребимыми являются:
      </p>
      <ul>
        <li><b>ltrim()</b>, <b>chop()</b>, <b>trim()</b> - удаляют
          все разделители соответственно в начале строки, в конце строки, в начале и
          конце строки. К разделителям относятся следующие символы:
          <b>"\n"</b> (новая строка), <b>"\r"</b> (возврат каретки),
          <b>"\t"</b> (табуляция), простой пробел.
        </li>
        <li><b>str_replace()</b> - заменяет все экземпляры указанной подстроки в
          строке на новую подстроку. Аргументы: заменяемая подстрока, замещающая
          подстрока, исходная строка. Например:
          <pre class="code">echo str_replace ("там", "тут", "Кто там?"); // выводит "Кто тут?"</pre>
        </li>
        <li><b>substr_replace()</b> - заменяет часть строки, ограниченную параметрами.
          Аргументы: исходная строка, замещающая подстрока, начальная позиция, длина
          заменяемой подстроки (необязательно). Если начальная позиция отрицательна, то
          отсчет идет от конца строки. Если длина не указана, используется вся длина
          строки. Если длина отрицательна, то замена завершается на указанной
          позиции от конца строки. Например:
          <pre class="code">echo substr_replace ("раз-два-три", "пять", 4, 3);  // выводит "раз-пять-три"
  echo substr_replace ("раз-два-три", "пять", 4);     // выводит "раз-пять"
  echo substr_replace ("раз-два-три", "пять", -3, 3); // выводит "раз-два-пять"
  echo substr_replace ("раз-два-три", "пять", 4, -3); // выводит "раз-пятьтри"</pre>
        </li>
        <li><b>strtoupper()</b> - переводит символы строки в верхний регистр.
        </li>
        <li><b>strtolower()</b> - переводит символы строки в нижний регистр.
        </li>
        <li><b>ucwords()</b> - переводит в верхний регистр первый символ каждого слова.
        </li>
        <li><b>explode()</b> - разбивает строку на массив.
          Аргументы: строка-разделитель и исходная строка. Например:
          <pre class="code">$строка = "Голова моя машет ушами";
  $массив = explode(" ",$str);
  // count ($массив) == 4
  // $массив[0] == "Голова"
  // $массив[1] == "моя"
  // $массив[2] == "машет"
  // $массив[3] == "ушами"</pre>
        </li>
        <li><b>implode()</b> -объединяет элементы массива со строкой.
          <pre class="code">$array = array('lastname', 'email', 'phone');
  $comma_separated = implode(",", $array);
  print $comma_separated; // lastname,email,phone</pre>
          <h2>Функции работы со строками в PHP</h2>
          <ul>
            <li>addcslashes - Экранирует спецсимволы в стиле языка C
            </li>
            <li>addslashes - Экранирует спецсимволы в строке
            </li>
            <li>bin2hex - Преобразует бинарные данные в шестнадцатиричное представление
            </li>
            <li>chr - Возвращает символ по его коду
            </li>
            <li>chunk_split - Разбивает строку на фрагменты
            </li>
            <li>convert_cyr_string - Преобразует строку из одной кириллической кодировки в другую
            </li>
            <li>count_chars - Возвращает информацию о символах, входящих в строку
            </li>
            <li>crc32 - Вычисляет CRC32 для строки
            </li>
            <li>crypt - Необратимое шифрование (хэширование)
            </li>
            <li>echo - Выводит одну или более строк
            </li>
            <li>explode - Разбивает строку на подстроки
            </li>
            <li>fprintf - Записывает отформатированную строку в поток
            </li>
            <li>get_html_translation_table - Возвращает таблицу преобразований
            </li>
            <li>hebrev - Преобразует текст на иврите из логической кодировки в визуальную
            </li>
            <li>hebrevc - Преобразует текст на иврите из логической кодировки в визуальную с преобразованием
              перевод
            </li>
            <li>htmlentities - Преобразует символы в соответствующие HTML сущности
            </li>
            <li>htmlspecialchars - Преобразует специальные символы в HTML сущности
            </li>
            <li>html_entity_decode - Преобразует HTML сущности в соответствующие символы
            </li>
            <li>implode - Объединяет элементы массива в строку(массив в строку)
            </li>
            <li>localeconv - Возвращает информацию о числовых форматах
            </li>
            <li>ltrim - Удаляет пробелы из начала строки
            </li>
            <li>md5 - Возвращает MD5 хэш строки
            </li>
            <li>md5_file - Возвращает MD5 хэш файла
            </li>
            <li>metaphone - Возвращает ключ metaphone для строки
            </li>
            <li>nl2br - Вставляет HTML код разрыва строки перед каждым переводом строки
            </li>
            <li>number_format - Форматирует число с разделением групп
            </li>
            <li>ord - Возвращает ASCII код символа
            </li>
            <li>parse_str - Разбирает строку в переменные
            </li>
            <li>print - Выводит строку
            </li>
            <li>printf - Выводит отформатированную строку
            </li>
            <li>quoted_printable_decode - Раскодирует строку, закодированную методом quoted printable
            </li>
            <li>quotemeta - Экранирует специальные символы
            </li>
            <li>rtrim - Удаляет пробелы из конца строки
            </li>
            <li>sha1 - Возвращает SHA1 хэш строки
            </li>
            <li>sha1_file - Возвращает SHA1 хэш файла
            </li>
            <li>similar_text - Вычисляет степень похожести двух строк
            </li>
            <li>soundex - Возвращает ключ soundex для строки
            </li>
            <li>sprintf - Возвращает отформатированную строку
            </li>
            <li>sscanf - Разбирает строку в соответствии с заданным форматом
            </li>
            <li>strcasecmp - Сравнение строк без учета регистра, безопасное для данных в двоичной форме
            </li>
            <li>strcmp - Сравнение строк, безопасное для данных в двоичной форме
            </li>
            <li>strcoll - Сравнение строк с учетом текущей локали
            </li>
            <li>strcspn - Возвращает длину участка в начале строки, не соответствующего маске
            </li>
            <li>stripcslashes - Удаляет экранирование символов, произведенное функцией addcslashes()
            </li>
            <li>stripos - Возвращает позицию первого вхождения подстроки без учета регистра
            </li>
            <li>stripslashes - Удаляет экранирование символов, произведенное функцией addslashes()
            </li>
            <li>strip_tags - Удаляет HTML и PHP тэги из строки
            </li>
            <li>stristr - Аналог функции strstr, но независит от регистра
            </li>
            <li>strlen - Возвращает длину строки
            </li>
            <li>strnatcasecmp - Сравнение строк без учета регистра с использованием алгоритма
            </li>
            <li>strnatcmp - Сравнение строк с использованием алгоритма "естественного упорядочения"
            </li>
            <li>strncasecmp - Сравнение первых n символов строк без учета регистра, безопасное для данных в
              двоичной форме
            </li>
            <li>strncmp - Сравнение первых n символов строк без учета регистра, безопасное для данных в двоичной
              форме
            </li>
            <li>strpos - Находит первое вхождение подстроки в строку
            </li>
            <li>strrchr - Находит последнее вхождение символа в строку
            </li>
            <li>strrev - Переворачивает строку
            </li>
            <li>strripos - Возвращает позицию последнего вхождения подстроки без учета регистра
            </li>
            <li>strrpos - Находит последнее вхождение символа в строку
            </li>
            <li>strspn - Возвращает длину участка в начале строки, соответствующего маске
            </li>
            <li>strstr - Находит первое вхождение подстроки
            </li>
            <li>strtok - Разбивает строку
            </li>
            <li>strtolower - Преобразует строку в нижний регистр
            </li>
            <li>strtoupper - Преобразует строку в верхний регистр
            </li>
            <li>strtr - Преобразует заданные символы
            </li>
            <li>str_ireplace - Регистро-независимый вариант функции str_replace().
            </li>
            <li>str_pad - Дополняет строку другой строкой до заданной длины
            </li>
            <li>str_repeat - Возвращает повторяющуюся строку
            </li>
            <li>str_replace - Заменяет строку поиска на строку замены
            </li>
            <li>str_rot13 - Выполняет над строкой преобразование ROT13
            </li>
            <li>str_shuffle - Переставляет символы в строке
            </li>
            <li>str_split - Преобразует строку в массив
            </li>
            <li>str_word_count - Возвращает информацию о словах, входящих в строку
            </li>
            <li>substr - Функция возвращает часть строки
            </li>
            <li>substr_count - Подсчитывает число вхождений подстроки в строку
            </li>
            <li>substr_replace - Заменяет часть строки
            </li>
            <li>trim - Удаляет пробелы из начала и конца строки
            </li>
            <li>ucfirst - Преобразует первый символ строки в верхний регистр
            </li>
            <li>ucwords - Преобразует в верхний регистр первый символ каждого слова в строке
            </li>
            <li>vprintf - Выводит отформатированную строку
            </li>
            <li>vsprintf - Возвращает отформатированную строку
            </li>
            <li>wordwrap - Выполняет перенос строки на данное количество символов с использованием символа
              разрыва строки
            </li>
          </ul>

          <h2> Особенности операторов сравнения применительно к строкам.</h2>
          <pre class="code">$one = 1;   // Число один.
  $zero = 0;  // Присваиваем число нуль.
  if ($one == "") echo 1;    // Очевидно, не равно - не выводит 1.
  if ($zero == "") echo 2;   //* Внимание! Вопреки ожиданиям печатает 2!
  if ("" == $zero) echo 3;   //* И это тоже не поможет - печатает!..
  if ("$zero" == "") echo 4; // Так правильно.
  if (strval($zero) == "") echo 5; // Так тоже правильно - не выводит 5.
  if ($zero === "") echo 6;  // Лучший способ, но не действует в PHP 3.
  </pre>

          <h4>chop()</h4>
          <p>Функция chop( ) возвращает строку после удаления из нее завершающих пропусков и символов новой строки.
            Синтаксис функции chop( ):
          </p>
          <p>string chop(string строка)
          </p>
          <p>В следующем примере функция chop( ) удаляет лишние символы новой строки:
          </p>
          <pre class="code">$header = "Table of Contents\n\n";
  $header = chop($header);
  // $header = "Table of Contents"
  </pre>


          <h4>str_pad()</h4>
          <p>Функция str_pad( ) выравнивает строку до определенной длины заданными символами и возвращает
            отформатированную строку. Синтаксис функции str_pad( ):
          </p>
          <p>string str_pad (string строка, int длина_дополнения [, string дополнение [, int тип_дополнения]])
          </p>
          <p>Если необязательный параметр дополнение не указан, строка дополняется пробелами. В противном случае
            строка дополняется заданными символами.
            По умолчанию строка дополняется справа; тем не менее, вы можете передать в параметре тип_дополнения
            константу STR_PAD_RIGHT, STR_PAD_LEFT или STR_PAD_BOTH,
            что приведет к дополнению строки в заданном направлении. Пример демонстрирует дополнение строки функцией
            str_pad( ) с параметрами по умолчанию:
          </p>
          <pre class="code">$food = "salad";
  print str_pad ($food, 5): // Выводит строку "salad
  </pre>
          В следующем примере используются необязательные параметры функции str_pad( ):
          <pre class="code">$header = "Table of Contents";
  print str_pad ($header, 5, "=+=+=", STR_PAD_BOTH);
  // В браузере выводится строка =+=+= Таbе of Contents=+=+="
  </pre>

          <h4>trim()</h4>
          <p>Функция trim( ) удаляет псе пропуски с обоих краев строки и возвращает полученную строку. Синтаксис
            функции trim( ):
          </p>
          <p>string trim (string страна]
          </p>
          <p>К числу удаляемых пропусков относятся и специальные символы \n, \r, \t, \v и \0.

          </p>
          <h4>ltrim()</h4>
          <p>Функция lrim( ) удаляет все пропуски и специальные символы с левого края строки и возвращает полученную
            строку. Синтаксис функции ltrim( ):
          </p>
          <p>string ltrim (string строка)
          </p>
          <p>Функция удаляет те же специальные символы, что и функция trim( ).

          </p>
          <h4>strlen()</h4>
          Определение длины строки
          <p>Длину строки в символах можно определить при помощи функции strlen( ). Синтаксис .функции strlen( ):
          </p>
          <p>int strlen (string строка)
          </p>
          <p>Следующий пример демонстрирует определение длины строки функцией strlen( ):
          </p>
          <pre class="code">$string = "hello";
  $length = strlen($string);
  // $length = 5</pre>

          <h2>Сравнение двух строк</h2>

          <p>Сравнение двух строк принадлежит к числу важнейших строковых операций любого языка.
            Хотя эту задачу можно решить несколькими разными способами, в РНР существуют четыре функции сравнения
            строк:
          </p>
          <ul>
            <li>strcmp()</li>
            <li>strcasecmp()</li>
            <li>strspn()</li>
            <li>strcspn()</li>
          </ul>

          <h4>strcmp()</h4>
          <p>Функция strcmp( ) сравнивает две строки с учетом регистра символов. Синтаксис функции strcmp( ):
            int strcmp (string строка1, string строка2)
          </p>
          <p>После завершения сравнения strcmp( ) возвращает одно из трех возможных значений:
          </p>
          <ul>
            <li>0, если строка1 и строка2 совпадают;</li>
            <li>&lt; 0, если строка1 меньше, чем строка2;</li>
            <li>&gt; 0, если строка2 меньше, чем строка1.</li>
          </ul>
          <p>В следующем фрагменте сравниваются две одинаковые строки:
          </p>
          <pre class="code">$sthng1 = "butter";
  $string2 = "butter";
  if ((strcmp($string1. $string2)) == 0) :
  print "Strings are equivalent!"; endif;
  // Команда if возвращает TRUE</pre>

          <h4>strcasecmp()</h4>
          <p>Функция strcasecmp( ) работает точно так же, как strcmp( ), за одним исключением - регистр символов при
            сравнении не учитывается.
            Синтаксис функции strcasecmp( ):
          </p>
          <p>int strcasecmp (string cтpoкa1, string строка2)
          </p>
          <p>В следующем фрагменте сравниваются две одинаковые строки:
          </p>
          <pre class="code">$string1 = "butter";
  $string2 = "Butter";
  if ((strcmp($string1, $string2)) == 0) :
  print "Strings are equivalent!";
  endif;
  // Команда if возвращает TRUE</pre>

          <h4>strspn()</h4>
          <p>Функция strspn( ) возвращает длину первого сегмента строки1, содержащего символы, присутствующие в
            строке2. Синтаксис функции strspn( ):
          </p>
          <p>int strspn (string строка1, string строка2)
          </p>
          <p>Следующий фрагмент показывает, как функция strspn( ) используется для проверки пароля:
          </p>
          <pre class="code">$password = "12345";
  if (strspn($password, "1234567890") != strlen($password)) :
  print "Password cannot consist solely of numbers!";
  endif:</pre>

          <h4>strcspn()</h4>
          <p>Функция strcspn( ) возвращает длину первого сегмента строки1, содержащего символы, отсутствующие в
            строке2. Синтаксис функции strcspn( ):
          </p>
          <p>int strcspn (string строка1, string строка2)
          </p>
          <p>В следующем фрагменте функция strcspn( ) используется для проверки пароля:
          </p>
          <pre class="code">$password = "12345";
  if (strcspn($password, "1234567890") == 0) :
  print "Password cannot consist solely of numbers!";
  endif;</pre>

          <h2>Обработка строковых данных без применения регулярных выражений</h2>
          <p>При обработке больших объемов информации функции регулярных выражений сильно замедляют выполнение
            программы.
            Эти функции следует применять лишь при обработке относительно сложных строк, в которых регулярные
            выражения действительно необходимы.
            Если же анализ текста выполняется по относительно простым правилам, можно воспользоваться стандартными
            функциями РНР,
            которые заметно ускоряют обработку. Все эти функции описаны ниже.

          </p>
          <h4>strtok()</h4>
          <p>Функция strtok( ) разбивает строку на лексемы по разделителям, заданным вторым параметром.
            Синтаксис функции strtok( ):
          </p>
          <p>string strtok (string строка, string разделители)
          </p>
          <p>У функции strtok( ) есть одна странность: чтобы полностью разделить строку,
            функцию необходимо последовательно вызвать несколько раз.
            При очередном вызове функция выделяет из строки следующую лексему.
            При этом параметр строка задается всего один раз - функция отслеживает текущую позицию в строке до тех
            пор,
            пока строка не будет полностью разобрана на лексемы или не будет задан новый параметр строка.
            Следующий пример демонстрирует разбиение строки по нескольким разделителям:
          </p>
          <pre class="code">$info = "WJ Gi1more:wjgilmore@hotmail.com | Columbus, Ohio";
  // Ограничители - двоеточие (:), вертикальная черта (|) и запятая (.)
  $tokens = ":|,";
  $tokenized = strtok($info, $tokens);
  // Вывести элементы массива $tokenized
  while ($tokenized) :
  echo "Element = $tokenized&lt;br&gt;";
  // Обратите внимание: при последующих вызовах strtok
  // первый аргумент не передается
  $tokenized = strtok($tokens);
  endwhile;</pre>
          <h4>parse_str()</h4>
          <p>Функция parse_str( ) выделяет в строке пары &lt;переменная-значение&gt; и присваивает значения
            переменных в текущей области видимости. Синтаксис функции parse_str( ):
          </p>
          <p>void parse_str (string строка)
          </p>
          <p>Функция parse_str( ) особенно удобна при обработке URL, содержащих данные форм HTML или другую
            расширенную информацию.
            В следующем примере анализируется информация, переданная через URL.
            Строка представляет собой стандартный способ передачи данных между страницами либо откомпилированных
            в гиперссылке, либо введенных в форму HTML:
          </p>
          <pre class="code">$url = "fname=wj&amp;lname=gilmore&amp;zip=43210";
  parse_str($url);
  // После выполнения parse_str( ) доступны следующие переменные:
  // $fname = "wj":
  // $lname = "gilmore";
  // $zip = "43210"</pre>
          <p>Поскольку эта функция создавалась для работы с URL, она игнорирует символ амперсанд (&amp;).

          </p>
          <h4>explode()</h4>
          <p>Функция explode() делит строку на элементы и возвращает эти элементы в виде массива. Синтаксис функции
            explode():
          </p>
          <p>array explode (string разделитель, string строка [, int порог])
          </p>
          <p>Разбиение происходит по каждому экземпляру разделителя, причем количество полученных
            фрагментов может ограничиваться необязательным параметром порог.
          </p>
          <p>Разделение строки функцией explode( ) продемонстрировано в следующем примере:
          </p>
          <pre class="code">$info = "wilson | baseball | indians";
  $user = explode("|", $info);
  // $user[0] = "wilson";
  // $user[1] = "baseball";
  // $user[2] = "Indians";</pre>
          <p>Функция explode( ) практически идентична функции регулярных выражений POSIX split( ), описанной выше.
            Главное различие заключается в том, что передача регулярных выражений в параметрах допускается только
            при вызове split( ).

          </p>
          <h4>implode()</h4>
          <p>Если функция explode( ) разделяет строку на элементы массива, то ее двойник - функция implode( ) -
            объединяет массив в строку. Синтаксис функции implode( ):
          </p>
          <p>string implode (string разделитель, array фрагменты)
          </p>
          <p>Формирование строки из массива продемонстрировано в следующем примере:
          </p>
          <pre class="code">$ohio_cities = array ("Columbus", "Youngstown", "Cleveland", "Cincinnati");
  $city_string = implode("l", $ohio_cities);
  // $city_string = "Columbus | Youngstown | Cleveland | Cincinnati";</pre>
          <p>У implode( ) имеется псевдоним - функция join( ).

          </p>
          <h4>strpos()</h4>
          <p>Функция strpos( ) находит в строке первый экземпляр заданной подстроки. Синтаксис функции strpos():
          </p>
          <p>int strpos (string строка, string подстрока [, int смещение])
          </p>
          <p>Необязательный параметр offset задает позицию, с которой должен начинаться поиск. Если подстрока не
            найдена, strpos() возвращает FALSE (0).
          </p>
          <p>В следующем примере определяется позиция первого вхождения даты в файл журнала:
          </p>
          <pre class="code">$log = "
  206.169.23.11:/www/:2000-08-10
  206.169.23.11:/www/logs/:2000-02-04
  206.169.23.11:/www/img/:1999-01-31";
  // В какой позиции в журнале впервые встречается 1999 год?
  $pos = strpos($log, "1999");
  // $pos = 95. поскольку первый экземпляр "1999"
  // находится в позиции 95 строки, содержащейся в переменной $log</pre>

          <h4>strrpos()</h4>
          <p>Функция strrpos( ) находит в строке последний экземпляр заданного символа. Синтаксис функции strrpos( ):
          </p>
          <p>int strpos (string строка, char символ)
          </p>
          <p>По возможностям эта функция уступает своему двойнику - функции strpos( ), поскольку она позволяет искать
            только отдельный символ,
            а не всю строку. Если во втором параметре strrpos( ) передается строка, при поиске будет использован
            только ее первый символ.

          </p>
          <h4>str_replace()</h4>
          <p>Функция str_replace( ) ищет в строке все вхождения заданной подстроки и заменяет их новой подстрокой.
            Синтаксис функции str_replace( ):
          </p>
          <p>string str_replace (string подстрока, string замена, string строка)
          </p>
          <p>Функция substr_replace( ), описанная ниже в этом разделе, позволяет провести заме ну лишь в определенной
            части строки.
            Ниже показано, как функция str_replace( ) используется для проведения глобальной замены в строке.
          </p>
          <p>Если подстрока ни разу не встречается в строке, исходная строка не изменяется:
          </p>
          <pre class="code">$favorite_food = "My favorite foods are ice cream and chicken wings";
  $favorite_food = str_replace("chicken_wings", "pizza", $favohte_food);
  // $favorite_food = "My favorite foods are ice cream and pizza"</pre>

          <h4>strstr()</h4>
          <p>Функция strstr( ) возвращает часть строки, начинающуюся с первого вхождения заданной подстроки. Синтаксис
            функции strstr( ):
          </p>
          <p>string strstr (string строка, string подстрока)
          </p>
          <p>В следующем примере функция strstr( ) используется для выделения имени домена из URL:
          </p>
          <pre class="code">$url = "http://www.apress.com"; $domain - strstr($url, ".");
  // $domain = ".apress.com"</pre>

          <h4>substr()</h4>
          <p>Функция substr( ) возвращает часть строки, начинающуюся с заданной начальной
            позиции и имеющую заданную длину. Синтаксис функции substr( ):
          </p>
          <p>string substr (string строка, int начало [, int длина])
          </p>
          <p>Если необязательный параметр длина не указан, считается, что подстрока начинается
            с заданной начальной позиции и продолжается до конца строки. При использовании этой
            функции необходимо учитывать четыре обстоятельства:
          </p>
          <ul>
            <li>если параметр начало положителен, возвращаемая подстрока начинается с позиции строки с заданным
              номером;
            </li>
            <li>если параметр начало отрицателен, возвращаемая подстрока начинается с позиции (длина строки -
              начало);
            </li>
            <li>если параметр длина положителен, в возвращаемую подстроку включаются все символы от позиции начало
              до позиции начало+длина. Если последняя величина превышает длину строки, возвращаются символы до
              конца строки;
            </li>
            <li>если параметр длина отрицателен, возвращаемая подстрока заканчивается на заданном расстоянии от
              конца строки.
            </li>
          </ul>
          <p>Помните о том, что параметр начало определяет смещение от первого символа строки;
            таким образом, возвращаемая строка в действительности начинается с символа с номером (начало + 1).
          </p>
          <p>Следующий пример демонстрирует выделение части строки функцией substr( ):
          </p>
          <pre class="code">$car = "1944 Ford"; Smodel = substr($car, 6);
  // Smodel = "Ford"</pre>
          <p>Пример с положительным параметром длина:
          </p>
          <pre class="code">$car = "1944 Ford";
  $model = substr($car, 0, 4);
  // $model = "1944"</pre>
          Пример с отрицательным параметром длина:
          <pre class="code">$car = "1944 Ford";
  $model = substr($car, 2, -5);
  // $model = "44"</pre>

          <h4>substr_count()</h4>
          Функция substr_count( ) возвращает количество вхождений подстроки в заданную строку. Синтаксис функции
          substr_count( ):
          int substr_count (string строка, string подстрока)
          В следующем примере функция substr_count( ) подсчитывает количество вхождений подстроки ain:
          <pre class="code">$tng_twist = "The rain falls mainly on the plains of Spain";
  $count = substr_count($tng_twist, "ain");
  // $count = 4</pre>

          <h4>substr_replace()</h4>
          <p>Функция substr_replace( ) заменяет часть строки, которая начинается с заданной позиции. Если задан
            необязательный параметр длина,
            заменяется фрагмент заданной длины; в противном случае производится замена по всей длине заменяющей
            строки.
            Синтаксис функции substr_replace( ):
          </p>
          <p>string substr_replace (string строка, string замена, int начало [, int длина])
          </p>
          <p>Параметры начало и длина задаются по определенным правилам:
          </p>
          <ul>
            <li>если параметр начало положителен, замена начинается с заданной позиции;
            </li>
            <li>если параметр начало отрицателен, замена начинается с позиции (длина строки -начало);
            </li>
            <li>если параметр длина положителен, заменяется фрагмент заданной длины;
            </li>
            <li>если параметр длина отрицателен, замена завершается в позиции (длина строки -длина).
            </li>
          </ul>
          <p>Простая замена текста функцией substr_replace( ) продемонстрирована в следующем примере:
          </p>
          <pre class="code">$favs = " 's favorite links";
  $name = "Alessia";
  // Параметры "0, 0" означают, что заменяемый фрагмент начинается
  // и завершается в первой позиции строки.
  $favs - substr_replace($favs, $name, 0, 0);
  print $favs:</pre>

          <h2>Преобразование строк и файлов к формату HTML и наоборот</h2>
          <p>Преобразовать строку или целый файл к формату, подходящему для просмотра в web-браузере (или наоборот),
            проще, чем может показаться на первый взгляд. В РНР для этого существуют специальные функции.

          </p>
          <h3>Преобразование текста в HTML</h3>
          <p>Быстрое преобразование простого текста к формату web-браузера - весьма распространенная задача.
            В ее решении вам помогут функции, описанные в этом разделе.
          </p>
          <h4>nl2br()</h4>
          <p>Функция nl2br() заменяет все символы новой строки (\n) эквивалентными конструкциями HTML.
          </p>
          <p>Синтаксис функции nl2br():
          </p>
          <p>string nl2br (string строка)
          </p>
          <p>Символы новой строки могут быть как видимыми (то есть явно включенными в строку), так и невидимыми
            (например, введенными в редакторе).
            В следующем примере текстовая строка преобразуется в формат HTML посредством замены символов \n
            разрывами строк:
          </p>
          <pre class="code">// Текстовая строка, отображаемая в редакторе.
  $text_recipe = "
  Party Sauce recipe:
  1 can stewed tomatoes
  3 tablespoons fresh lemon juice
  Stir together, server cold.";
  // Преобразовать символы новой строки в <br>
  $htinl_recipe = nl2br($text_recipe)</pre>
          При последующем выводе $html_recipe браузеру будет передан следующий текст в формате HTML:
          <pre class="code">Party Sauce recipe:&lt;br&gt;
  1 can stewed tomatoes&lt;br&gt;
  3 tablespoons fresh lemon juice&lt;br&gt;
  Stir together, server cold.&lt;br&gt;</pre>

          <h4>htmlentities()</h4>
          <p>Функция htmlentities( ) преобразует символы в эквивалентные конструкции HTML. Синтаксис функции
            htmlentities:
          </p>
          <p>string htmlentities (string строка)
          </p>
          <p>В следующем примере производится необходимая замена символов строки для вывода в браузере:
          </p>
          <pre class="code">$user_input = "The cookbook, entitled Cafe Francaise' costs &lt; $42.25.";
  $converted_input = htmlentities($user_input);
  // $converted_input = "The cookbook, entitled 'Cafè
  // Fracçiaise' costs &lt; 42.25.";</pre>
          <p>Функция htmlentities( ) в настоящее время работает только для символов кодировки ISO-8559-1
            (ISO-Latin-1).
            Кроме того, она не преобразует пробелы в &nbsp;, как следовало бы ожидать.

          </p>
          <h4>htmlspecialchars()</h4>
          <p>Функция htmlspecialchars( ) заменяет некоторые символы, имеющие особый смысл в контексте HTML,
            эквивалентными конструкциями HTML.
            Синтаксис функции htmlspecialchars( ):
          </p>
          <p>string htmlspecialchars (string строка)
          </p>
          <p>Функция html special chars( ) в настоящее время преобразует следующие символы:
            &amp; преобразуется в &amp;; " " преобразуется в ";
            &lt; преобразуется в &lt;; &gt; преобразуется в &gt;.
          </p>
          <p>В частности, эта функция позволяет предотвратить ввод пользователями разметки HTML в интерактивных
            web-приложениях
            (например, в электронных форумах). Ошибки, допущенные в разметке HTML, могут привести к тому, что вся
            страница
            будет формироваться неправильно. Впрочем, у этой задачи существует и более эффективное решение
            - полностью удалить теги из строки функцией strip_tags( ).
          </p>
          <p>Следующий пример демонстрирует удаление потенциально опасных символов функцией htmlspeclalchars( ):
          </p>
          <pre class="code">$user_input = "I just can't get &lt;enough&gt; of PHP &amp; those fabulous cooking recipes!";
  $conv_input = htmlspecialchars($user_input);
  // $conv_input = "I just can't &lt;&lt;enough&gt;&gt; of PHP &amp; those fabulous cooking
  recipes!"</pre>
          <p>Если функция htmlspecialchars( ) используется в сочетании с nl2br( ), то последнюю следует вызывать после
            htmlspecialchars( ).
            В противном случае конструкции &lt;br&gt;, сгенерированные при вызове nl2br( ), преобразуются в видимые
            символы.

          </p>
          <h4>get_html_translation_table()</h4>
          <p>Функция get_html_translation_table( ) обеспечивает удобные средства преобразования текста в эквиваленты
            HTML Синтаксис функции get_htrril_translation_table( ):
          </p>
          <p>string get_html_translation_table (int таблица)
          </p>
          <p>Функция get_html_translation_table( ) возвращает одну из двух таблиц преобразования (определяется
            параметром таблица),
            используемых в работе стандартных функций htmlspecialchars( ) и htmlentities( ).
            Возвращаемое значение может использоваться в сочетании с другой стандартной функцией, strtr(), для
            преобразования текста в код HTML.
          </p>
          <p>Параметр таблица принимает одно из двух значений:
          </p>
          <ul>
            <li>HTML_ENTITIES;
            </li>
            <li>HTML_SPECIALCHARS.
            </li>
          </ul>
          <p>В следующем примере функция get_html_translation_table( ) используется при преобразовании текста в код
            HTML:
          </p>
          <pre class="code">$string = "La pasta e il piatto piu amato in Italia";
  $translate = get_html_translation_table(HTML_ENTITIES);
  print strtr($string, $translate);
  // Специальные символы преобразуются в конструкции HTML
  // и правильно отображаются в браузере.</pre>
          <p>Кстати, функция array_flip( ) позволяет провести преобразование текста в HTML в обратном направлении и
            восстановить исходный текст. Предположим, что вместо вывода результата strtr( ) в предыдущем примере мы
            присвоили его переменной $translated string.
          </p>
          <p>В следующем примере исходный текст восстанавливается функцией array_flip( ):
          </p>
          <pre class="code">$translate = array_flip($translate);
  $translated_string - "La pasta é il piatto piú amato in Italia";
  $original_string = strtr($translated_string, $translate);
  // $original_string = "La pasta e il piatto piu amato in Italia"; </pre>

          <h4>strtr()</h4>
          <p>Функция strtr( ) транслирует строку, то есть заменяет в ней все символы, входящие в строку источник,
            соответствующими символами строки приемник. Синтаксис функции strtr( ):
          </p>
          <p>string strtr (string строка, string источник, string приемник)
          </p>
          <p>Если строки источник и приемник имеют разную длину, длинная строка усекается до размеров короткой строки.
          </p>
          <p>Существует альтернативный синтаксис вызова strtr( ) с двумя параметрами; в этом случае второй параметр
            содержит ассоциативный массив, ключи которого соответствуют заменяемым подстрокам, а значения -
            заменяющим подстрокам. В следующем примере теги HTML заменяются XML-подобными конструкциями:
          </p>
          <pre class="code">&lt;?
  $source = array("&lt;title&gt;" =&gt; "&lt;h2&gt;", "&lt;/title&gt;" =&gt; "&lt;/h2&gt;");
  $string = "&lt;h2&gt;Today In PHP-Powered News&lt;/h2&gt;";
  print strtr($string, $source);
 // Выводится строка "&lt;title&gt;Today in PHP-Powered News&lt;/title&gt;"
  ?&gt;</pre>

          <h3>Преобразование HTML в простой текст</h3>
          <p>Иногда возникает необходимость преобразовать файл в формате HTML в простой текст. Функции, описанные
            ниже, помогут вам в решении этой задачи.

          </p>
          <h4>strip_tags()</h4>
          <p>Функция strip_tags( ) удаляет из строки все теги HTML и РНР, оставляя в ней только текст. Синтаксис
            функции strip_tags( ):
          </p>
          <p>string strip_tags (string строка [, string разрешенные_тerи])
          </p>
          <p>Необязательный параметр разрешенные_теги позволяет указать теги, которые должны пропускаться в процессе
            удаления.
          </p>
          <p>Ниже приведен пример удаления из строки всех тегов HTML функцией strip_tags( ):
          </p>
          <pre class="code">$user_input = "I just <b>love</b> РНР and <i>gourment</i> recipes!";
  $stripped_input = strip_tags($user_input);
  // $stripped_input = "I just love PHP and gourmet recipes!";</pre>
          <p>В следующем примере удаляются не все, а лишь некоторые теги:
          </p>
          <pre class="code-wrapper">$input = "I &amp;lt;b&gt;love&amp;lt;/b&gt; to &amp;lt;a href = \"http://www.eating.com\"&gt;eat!&amp;lt;/a&gt;!";
  $strip_input = strip_tags ($user_input, "&amp;lt;a&gt;");
 // $strip_input = "I love to &amp;lt;a href = \"http://www.eating.com\"&gt;eat!&amp;lt;/a&gt;!";</pre>
          <p>Удаление тегов из текста также производится функцией fgetss().

          </p>
          <h4>get_meta_tags()</h4>
          <p>Хотя функция get_meta_tags( ) и не имеет прямого отношения к преобразованию текста, зто весьма полезная
            функция, о которой следует упомянуть.
            Синтаксис функции get_meta_tags( ):
          </p>
          <p>array get_meta_tags (string имя_файла/URL [, int включение_пути])
          </p>
          <p>Функция get_meta_tags( ) предназначена для поиска в файле HTML тегов МЕТА.
          </p>
          <p>Теги МЕТА содержат информацию о странице, используемую главным образом поисковыми системами.
            Эти теги находятся внутри пары тегов .... Применение тегов МЕТА продемонстрировано
            в следующем фрагменте (назовем его example.html, поскольку он будет использоваться в листинге 8.2):
            Функция get_meta_tags( ) ищет в заголовке документа теги, начинающиеся словом МЕТА,
            и сохраняет имена тегов и их содержимое в ассоциативном массиве.
            В листинге 8.2 продемонстрировано применение этой функции к файлу example.html.

            Листинг 8.2. Извлечение тегов МЕТА из файла HTML функцией get_meta_tags( )

          </p>
          <pre class="code">$meta_tags = get_meta_tags("example.html"):
  // Переменная $meta_tags содержит массив со следующей информацией:
  // $meta_tags["keywords"] = "PHP, code, recipes, web"
  // $meta_tags["description"] = "Информация о PHP"
  // $meta_tags["author"] = "KDG";</pre>
          <p>Интересная подробность: данные тегов МЕТА можно извлекать не только из файлов, находящихся на сервере, но
            и из других URL.

          </p>
          <h3>Преобразование строки к верхнему и нижнему регистру</h3>
          <p>В РНР существует четыре функции, предназначенных для изменения регистра строки:
          </p>
          <ul>
            <li>strtolower();
            </li>
            <li>strtoupper()</a>;
            </li>
            <li>ucfirst()</a>;
            </li>
            <li>ucwords()</a>.
            </li>
          </ul>
          <h4>strtolower( )</h4>
          <p>Функция strtolower( ) преобразует все алфавитные символы строки к нижнему регистру. Синтаксис функции
            strtolower():
          </p>
          <p>string strtolower(string строка)
          </p>
          <p>Неалфавитные символы функцией не изменяются. Преобразование строки к нижнему регистру функцией
            strtolower() продемонстрировано в следующем примере:
          </p>
          <pre class="code">$sentence = "COOKING and PROGRAMMING PHP are my TWO favorite!";
  $sentence = strtolower($sentence);
  // После вызова функции $sentence содержит строку
  // "cooking and programming php are my two favorite!"</pre>

          <h4>strtoupper()</h4>
          <p>Строки можно преобразовывать не только к нижнему, но и к верхнему регистру. Преобразование выполняется
            функцией strtoupper(), имеющей следующий синтаксис:
          </p>
          <p>string strtoupper (string строка)
          </p>
          <p>Неалфавитные символы функцией не изменяются. Преобразование строки к верхнему регистру функцией
            strtoupper() продемонстрировано в следующем примере:
          </p>
          <pre class="code">$sentence = "cooking and programming PHP are my two favorite!";
  $sentence = strtoupper($sentence);
  // После вызова функции $sentence содержит строку
  // "COOKING AND PROGRAMMING PHP ARE MY TWO FAVORITE!"</pre>

          <h4>ucfirst()</h4>
          <p>Функция ucfirst( ) преобразует к верхнему регистру первый символ строки - при условии, что он является
            алфавитным символом. Синтаксис функции ucfirst():
          </p>
          <p>string ucfirst (string строка)
          </p>
          <p>Неалфавитные символы функцией не изменяются. Преобразование первого символа строки функцией ucfirst()
            продемонстрировано в следующем примере:
          </p>
          <pre class="code">&amp;sentence = "cooking and programming PHP are my two favorite!";
  $sentence = ucfirst($sentence);
  // После вызова функции $sentence содержит строку
  // "Cooking and programming PHP are mу two favorite!"</pre>

          <h4>ucwords()</h4>
          <p>Функция ucwords( ) преобразует к верхнему регистру первую букву каждого слова в строке. Синтаксис функции
            ucwords():
          </p>
          <p>string ucwords (string строка")
          </p>
          <p>Неалфавитные символы функцией не изменяются. "Слово" определяется как последовательность символов,
            отделенная от других элементов строки пробелами. В следующем примере продемонстрировано преобразование
            первых символов слов функцией ucwords( ):
          </p>
          <pre class="code">$sentence = "cooking and programming PHP are my two favorite!";
  $sentence = ucwords($sentence);
  // После вызова функции $sentence содержит строку
  // "Cooking And Programming PHP Are My Two Favorite!"</pre>

          <h4>strrchr()</h4>
          <p>strrchr("строка", "о") - Находит последнее вхождение подстроки
          </p>
          <p>Если подстрока не найдена, возвращает FALSE.
          </p>
          <p>В отличие от strchr(), если искомая строка состоит более чем из одного символа, используется только
            первый символ.
          </p>
          <p>Если второй параметр не является строкой, он приводится к целому и трактуется как код символа.
          </p>
          <pre class="code">// получить последнюю директорию из $PATH
  $dir = substr(strrchr($PATH, ":"), 1);
  // получить все после последнего перевода строки
  $text = "Line 1\nLine 2\nLine 3";
  $last = substr(strrchr($text, 10), 1 );</pre>


          <h4>highlight_string()</h4>
          highlight_string- выделение синтаксиса строки.
          <p>mixed highlight_string (string str [, bool return])
          </p>
          <p>Функция highlight_string() выводит версию с расцвеченным синтаксисом строки str, используя цвета,
            определённые во встроенном выделении синтаксиса PHP.
          </p>
          <p>Если второй параметр return имеет значение TRUE, то highlight_string() возвратит версию раскрашенного
            кода как строку, вместо её печати. Если второй параметр не имеет значение TRUE, highlight_string()
            возвратит TRUE при успехе, FALSE при неудаче.
          </p>
          <p>Примечание: 1.параметр return стал доступен, начиная с PHP 4.2.0. До этого он работал, как по умолчанию,
            т.е. FALSE.<br>
            2.Функция Highlight_String() различает PHP код по тегам &lt;?php ?&gt;.
            <b>show_source()</b> - синоним <b>highlight_file()</b>.
            Для изменения цвета выделения по умолчанию используйте следующие PHP директивы:
          </p>
          <pre class="code">highlight.bg #FFFFFF
  highlight.comment #FF8000
  highlight.default #0000BB
  highlight.html #000000
  highlight.keyword #007700
  highlight.string #DD0000</pre>
          в .htaccess:
          <pre class="code">php_flag highlight.bg #FFFFFF</pre>
          в PHP:
          <pre class="code">if(@ini_get('highlight.bg')=='') ... </pre>
          <h4>addslashes()</h4> - Экранирует спецсимволы в строке
          <p>Возвращает сроку, в которой перед каждым спецсимволом добавлен обратный слэш (\),
            например для последующего использования этой строки в запросе к базе данных.
          </p>
          <p>Экранируются одиночная кавычка ('), дойная кавычка ("), обратный слэш (\) и NUL (байт NULL).
          </p>
          <pre class="code">$str = "Is your name O'reilly?";
  // выводит: Is your name O\'reilly?
  echo addslashes($str);</pre>

          <h4>stripslashes</h4> - Удаляет экранирование символов, произведенное функцией addslashes()
          Удаляет экранирующие бэкслэши. (\' преобразуется в ', и т.д.). Двойные бэкслэши (\\) преобразуется в
          одиночные(\).

          <h4>wordwrap()</h4> Выполняет перенос строки на данное количество символов с использованием символа разрыва
          строки
          <pre class="code">// Использование wordwrap().
  function cite($ourText, $maxlen=60, $prefix="&gt; ") {
     $st = wordwrap($ourText, $maxlen-strlen($prefix), "\n");
     $st = $prefix.str_replace("\n", "\n$prefix", $st);
     return $st;
  }
  echo cite("The first Matrix I designed was quite naturally
  perfect, it was a work of art - flawless, sublime. A triumph
  equalled only by its monumental failure. The inevitability
  of its doom is apparent to me now as a consequence of the
  imperfection inherent in every human being. Thus, I
  redesigned it based on your history to more accurately reflect
  the varying grotesqueries of your nature. However, I was again
  frustrated by failure.", 20);</pre>
          <button type="button" class="button"><a class="button__link" href="php4.html">Предыдущая лекция</a></button>
          <button type="button" class="button"><a class="button__link" href="php6.html">Следующая лекция</a></button>

    </main>

  </div>

  <script src="../../js/accessibility.js"></script>

</body>

</html>
