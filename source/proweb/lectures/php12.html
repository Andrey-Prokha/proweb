<!DOCTYPE html>
<html class="page" lang="ru">

<head>
  <meta charset="utf-8">
  <title>PHP Кэширование</title>
  <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body class="page__body">

  <section class="modal">
    <div class="modal__wrapper">
      <div class="modal__block">
        <h3 class="modal__title">Размер шрифта:</h3>
        <button type="button" class="button button--accessibility fontsize-standart"
          title="Стандартный размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-2x"
          title="Увелеченный дважды размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-4x"
          title="Увелеченный четырежды размер шрифта">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Цвет сайта:</h3>
        <button type="button" class="button button--accessibility color-whiteblack" title="Бело-черный стиль">А</button>
        <button type="button" class="button button--accessibility color-blackwhite" title="Черно-белый стиль">А</button>
        <button type="button" class="button button--accessibility color-blue" title="Сине-голубой стиль">А</button>
        <button type="button" class="button button--accessibility color-standart" title="Стандартный стиль">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Изображения:</h3>
        <button type="button" class="button button--accessibility image-off" title="Отключить изображение"><span
            class="visually-hidden">Выкл.</span></button>
        <button type="button" class="button button--accessibility image-on" title="Включить изображение"><span
            class="visually-hidden">Вкл.</span><svg class="image__svg" version="1.1" xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 350 350">
            <path
              d="M5,350h340V0H5V350z M25,330v-62.212h300V330H25z M179.509,247.494H60.491L120,171.253L179.509,247.494z   M176.443,211.061l33.683-32.323l74.654,69.05h-79.67L176.443,211.061z M325,96.574c-6.384,2.269-13.085,3.426-20,3.426  c-33.084,0-60-26.916-60-60c0-6.911,1.156-13.612,3.422-20H325V96.574z M25,20h202.516C225.845,26.479,225,33.166,225,40  c0,44.112,35.888,80,80,80c6.837,0,13.523-0.846,20-2.518v130.306h-10.767l-104.359-96.526l-45.801,43.951L120,138.748  l-85.109,109.04H25V20z" />
          </svg></button>
      </div>
    </div>
  </section>

  <button type="button" class="accessibility" title="Открыть панель доступности"><svg width="50" height="50"
      viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
      <path class="accessibility__svg"
        d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
      </path>
    </svg></button>
  <div class="page__wrapper">

    <header class="header">

      <nav class="nav">
        <ul class="nav__list">
          <li class="nav__item">
            <a class="nav__link" href="../../index.html">Главная</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../lectures.html">Лекции</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../video.html">Видео-уроки</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../practical.html">Лабораторные работы</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../tests.html">Тесты</a>
          </li>
        </ul>
      </nav>

    </header>

    <main class="content">
      <h1 class="content__title">Кэширование в PHP</h1>
      <h2>Введение</h2>
      <p>В старые добрые времена, когда создание web-сайтов представляло из себя
        такое простое занятие, как набор нескольких <em>HTML</em>-страниц,
        отправка web-страниц в браузер была простой отправкой файла web-сервером.
        Посетители сайта могли видеть эти небольшие, исключительно текстовые
        странички, почти мгновенно (если не считать пользователей медленных
        модемов). Как только страница была загружена, браузер кэширует её
        где-нибудь на локальном компьютере, чтобы в случае повторного запроса
        страницы, можно было взять его локальную версию из кэша, послав лишь
        короткий запрос, чтобы убедиться, что страница на сервере не была
        изменена. Запросы обрабатывались быстро и как можно эффективней, и все
        были счастливы (кроме использующих модемы 9600 бод).</p>
      <p>Появление динамических web-страниц изменило положение вещей в худшую
        сторону, эффективно «сломав» эту модель обслуживания web-страниц благодаря
        наличию двух проблем:</p>
      <ol>
        <li>Когда сервером получен запрос динамической web-странички,
          производится некоторая промежуточная обработка, например синтаксический
          анализ (парсинг) скрипта движком <em>PHP</em>, которая должна быть
          завершена. Благодаря этому получаем задержку перед тем, как web-сервер
          начнёт отправку вывода в браузер. Для простого <em>PHP</em>-скрипта это
          не существенно, но для более сложного приложения движок <em>PHP</em>
          может выполнить много действий прежде чем страница будет готова для
          отправки. Эти дополнительные действия приводят к заметной задержке между
          запросами пользователей и реальным отображением страниц в их браузерах.
        </li>
        <li>Типичный web-сервер, например Apache, использует время модификации
          файла чтобы правильно сообщить web-браузеру состояние кэша запрашиваемой
          странички. Для динамических web-страниц, фактически <em>PHP</em>-скрипт
          может изменяться только изредка, в то время как отображаемый им контент,
          возможно располагающийся в базе данных, изменяется часто. Web-сервер не
          имеет возможности знать о наличии изменений в базе данных, тем не менее
          он не отправляет дату последней модификации. Если клиент (браузер) не
          получает никакого признака того, как долго данные являются корректными,
          он предполагает, что в следующий раз необходимо запросить страничку по
          новой. Web-сервер всегда будет отвечать обновлённой версией странички,
          независимо от того, изменились ли данные. Чтобы избежать этого
          недостатка большинство web-разработчиков используют мета-тэги или
          <em>HTTP</em>-заголовки, чтобы сообщить браузеру никогда не использовать
          кэшированную версию странички. Однако это отрицает естественную
          способность web-браузера кэшировать web-страницы и обладает некоторыми
          существенными недостатками. Например, содержание динамической странички
          может изменяться раз в сутки, поэтому выгода, получаемая от наличия даже
          24-часового кэширования странички браузером, очевидна.
        </li>
      </ol>
      <p>Обычно для маленьких PHP-приложений вполне можно игнорировать
        существование этих проблем, однако с увеличением сложности и повышением
        трафика Вашего сайта Вы можете столкнуться с проблемами. Тем не менее, обе
        эти проблемы могут быть решены, первая путём кэширования на стороне
        сервера, вторая путём управления кэшированием на стороне клиента из вашего
        приложения. Подход, который вы будете использовать для решения проблем,
        будет зависеть от вашей области применения, но в этой главе мы увидим, как
        вы можете решить обе проблемы используя PHP и некоторые классы библиотеки
        <em>PEAR</em>.
      </p>

      <h2>Как я предотвращаю кэширование страницы браузерами?</h2>
      <p>Прежде чем мы рассмотрим методы клиентского и серверного кэширования, в
        первую очередь мы должны понять, как вообще предотвратить кэширование
        страниц web-браузером (и прокси-серверами). Основной способ достижения
        этого использует мета-тэги HTML:</p>
      <pre class="code"> &lt;meta http-equiv="Expires" content="Mon, 26 Jul 1997 05:00:00 GMT" /&gt;
     &lt;meta http-equiv="Pragma" content="no-cache" /&gt;
    </pre>
      <p>Вставив прошедшую дату в мета-тэг Expires, вы сообщаете браузеру, что
        кэшированная копия странички всегда является устаревшей. Это значит, что
        браузер никогда не должен кэшировать страницу. Мета-тэг <strong>Pragma:
          no-cache</strong> довольно хорошо поддерживаемое соглашение, которому
        следует большинство web-браузеров. Обнаружив этот тэг, они обычно не
        кэшируют страницу (хотя никаких гарантий нет, это всего лишь
        соглашение).</p>
      <p>Это хорошо звучит, но есть две проблемы, связанные с использованием
        мета-тэгов:</p>
      <ol>
        <li>Если тэг не существовал когда страница была запрошена браузером
          впервые, но появляется позже (например, вы модифицировали включаемый
          файл <strong>pageheader.php</strong> который является шапкой
          каждой web-страницы), браузер останется в блаженном неведении и
          воспользуется свей кэшированной копей оригинала.
        </li>
        <li>Прокси-серверы, кэширующие web-страницы, как например общий
          <em>ISP</em>, вообще не будет исследовать непосредственно содержимое
          <em>HTML</em>-документа. Вместо этого они полагаются только на
          web-сервер, с которого пришли документы, и протокол <em>HTTP</em>. Иными
          словами, web-браузер может считать, что не должен кэшировать страницу,
          но прокси-сервер между браузером и вашим web-сервером вероятно не знает
          этого – и продолжит отправлять клиенту ту же самую, уже устаревшую,
          страницу.
        </li>
      </ol>
      <p>Лучший подход состоит в том, чтобы использовать непосредственно
        протокол <em>HTTP</em> с помощью функции PHP <b>header()</b>,
        эквивалентно приведённым выше двум мета-тэгам:</p>
      <pre class="code">header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
    header('Pragma: no-cache');</pre>
      <p>Мы можем пойти на один шаг вперёд, воспользовавшись заголовком
        <strong>Cache-Control</strong>&nbsp;&nbsp;совместимым с браузерами,
        поддерживающими <em>HTTP</em> 1.1:
      </p>
      <pre class="code">header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
    header('Cache-Control: no-store, no-cache, must-revalidate');
    header('Cache-Control: post-check=0, pre-check=0', FALSE);
    header('Pragma: no-cache');</pre>
      <p>Это гарантирует, что никакой web-браузер или промежуточный
        прокси-сервер не будет кэшировать страницу, таким образом посетители
        всегда получат самую последнюю версию контента. Фактически, первый
        заголовок должен быть самодостаточным, это лучший способ гарантировать,
        что страница не кэшируется. Заголовки <strong>Cache-Control</strong> и
        <strong>Pragma</strong> добавлены с целью «подстраховаться». Хотя они не
        работают во всех браузерах или прокси, они отловят некоторые случаи, в
        которых <strong>Expires</strong> не работает должным образом (например,
        если дата на компьютере клиента установлена неправильно).
      </p>
      <p>Конечно, полный отказ от кэширования обеспечивает нас проблемами,
        которые мы обсуждали в начале этой главы. Сейчас мы рассмотрим решение
        этих проблем.</p>
      <h3>Internet Explorer и кэширование загрузки файлов</h3>
      <p>Если при обслуживании загрузки
        файла <em>PHP</em>-скриптом используются такие заголовки, как например
        <strong>Content-Disposition: attachment, filename=myFile.pdf</strong> или
        <strong>Content-Disposition: inline,
          filename=myFile.pdf</strong> у вас будут проблемы с
        <em>Internet Explorer</em>’ом, если вы сообщите браузеру не кэшировать
        страницу.
      </p>
      <p><em>Internet Explorer</em> оперирует загрузкой довольно необычным
        образом, выполняя два запроса к web-сайту. Первый запрос загружает файл и
        сохраняет его в кэше, пока не будет создан второй запрос (без сохранения
        отклика). Этот запрос вызывает процесс передачи файла конечному
        пользователю в соответствии с типом файла (например, запускает <em>Acrobat
          Reader</em>, если файл является <em>PDF</em>-документом). Это значит, что
        если вы отправили заголовки, запрещающие браузеру кэшировать страницу,
        <em>Internet Explorer</em> удалит файл между первым и вторым запросом, в
        результате чего конечный пользователь ничего не получит. Если файл,
        который вы отдаёте <em>PHP</em>-скриптом, не изменяется, одним из
        простейших решений будет убрать «запрещающие кэширование» заголовки из
        скрипта.
      </p>
      <p>Если загружаемый файл регулярно изменяется (т.е. вы хотите, чтобы
        браузер загружал новейшую версию), вы должны использовать заголовок
        <strong>Last-Modified</strong>, который будет рассмотрен в этой
        главе позднее, и гарантировать, что время модификации между двумя
        последовательными запросами не изменяется. Вы должны сделать это таким
        образом, чтобы не повлиять на пользователей браузеров, правильно
        оперирующих загрузкой. Одним из решений в этом случае будет сохранение
        файла на вашем web-сервере и предоставление простой ссылку к нему,
        предоставив web-серверу сообщать за вас заголовки кэширования. Конечно,
        это решение не может быть приемлемым, если предполагается авторизованный
        доступ к файлу, это решение допускает непосредственную загрузку
        сохранённого файла.
      </p>
      <h2>Как я могу захватить данные на стороне сервера для кэширования?</h2>
      <p>Пришло время взглянуть на то, как мы можем уменьшить задержку при
        помощи кэширования вывода на стороне сервера. Общий подход начинает
        предоставлять страницу как обычно, выполняя запросы к базе данных и так
        далее на <em>PHP</em>. Тем не менее, перед отправкой результата в браузер,
        мы захватываем его и сохраняем готовую страницу, например, в файле. При
        следующем запросе, <em>PHP</em>-скрипт сначала проверяет наличие
        кэшированной версии страницы. Если она существует, скрипт отправляет в
        браузер версию из кэша, исключая таким образом задержку на повторное
        создание страницы.</p>

      <h3>Несколько слов о кэшировании при помощи шаблонов</h3>
      <p>Шаблонные движки часто говорят о кэшировании шаблонов. Обычно эти
        движки предлагают встроенный механизм для сохранения откомпилированной
        версии шаблона (т.е. генерируют из шаблона <em>PHP</em>-исходник), что
        предохраняет нас от необходимости парсить шаблон каждый раз, когда
        запрашивается страница. Это не нужно путать с кэшированием вывода, которое
        имеет отношение к кэшированию предоставляемого <em>HTML</em> (или другого
        вывода), который посылает <em>PHP</em> в браузер. Вы можете успешно
        использовать оба типа кэширования одновременно на одном и том же
        сайте.</p>
      <p>Сейчас мы рассмотрим встроенный механизм кэширования на <em>PHP</em>,
        использующий буферизацию вывода, который может использоваться вами
        независимо от способа создания контента (с шаблонами или без шаблонов).
        Рассмотрим ситуацию в которой ваш скрипт отображает результат использую, к
        примеру, <strong>echo</strong> или <strong>print</strong>, чтобы выдать
        данные непосредственно в браузер. В таком случае вы можете использовать
        функции управления выводом <em>PHP</em> для хранения данных в буферной
        памяти, над которой ваш <em>PHP</em>-скрипт имеет и доступ, и
        контроль.</p>
      <h5>Пример 1. Файл: 1.php</h5>
      <pre class="code">// Начинаем буферизацию вывода
    ob_start();

    // Выводим некоторый текст (который сохраняется в буфере);
    echo '1. Выводим это в буфер&lt;br /&gt;';

    // Получаем содержимое буфера
    $buffer = ob_get_contents();

    // Останавливаем буферизацию и очищаем буфер вывода
    ob_end_clean();

    // Выводим некоторый текст обычным образом
    echo '2. Нормальный вывод&lt;br /&gt;';

    // Вывод содержимого буфера
    echo $buffer;</pre>

      <p>Сам буфер хранит вывод как строку. Так, в вышеприведённом скрипте мы
        начинаем буферизацию с ob_start()
        и используем <strong>echo</strong>, чтобы
        вывести что-либо. Затем мы используем ob_get_contents(),
        чтобы выбрать данные, помещённые в буфер оператором <strong>echo</strong>,
        и сохранить их в строке. Функция ob_end_clean() останавливает буферизацию вывода и
        уничтожает его содержимое, как альтернативу можно использовать ob_end_flush(), чтобы
        вывести содержимое буфера.</p>

      <p>Другими словами, мы захватили вывод первого <strong>echo</strong>,
        затем послали его браузеру после второго <strong>echo</strong>. Как видно
        из этого простого примера, буферизация вывода является очень мощным
        инструментом для формирования вашего сайта, она обеспечивает решение для
        кэширования, как мы скоро увидим, и является отличным способом скрыть
        ошибки от посетителей вашего сайта (смотрите Обработка ошибок).
        Она также обеспечивает альтернативную возможность для переадресации
        браузера в ситуациях типа аутентификации пользователя.</p>
      <h3>Заголовки HTTP и буферизация вывода</h3>
      <p>Буферизация вывода может помочь решить наиболее общую проблему,
        связанную с функцией header(), не говоря уже о
        session_start() и setcookie(). Обычно, если вы вызываете любую из этих функций после того, как начался
        вывод страницы, вы получите противное сообщение об ошибке. При включенной буферизации вывода единственным типом
        вывода, избегающим буферизации, являются <em>HTTP</em>-заголовки. Используя <strong>ob_start()</strong> в
        самом начале выполнения вашего приложения, вы можете посылать заголовки в
        любой понравившейся точке программы, не сталкиваясь с обычными ошибками.
        Затем, как только вы будете уверены, что больше выводить
        <em>HTTP</em>-заголовки не потребуется, вы можете сразу же вывести
        содержимое страницы из буфера.
      </p>

      <h3>Использование буферизации вывода для кэширования на стороне
        сервера</h3>
      <p>Вы уже видели базовый пример буферизации вывода, теперь следующий шаг,
        в котором буфер сохраняется в файл:</p>

      <h5>Пример 2. Файл: 2.php</h5>
      <pre class="code">// Если существует кэшированная версия:
      if (file_exists('./cache/2.cache')) {
        // Читаем и выводим файл
        readfile('./cache/2.cache');
        exit();
      }

      // Начинаем буферизацию вывода
      ob_start();

      // Выводим остальной HTML
    ?&gt;
    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
    &lt;title&gt;Кэшированная страница&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
    Эта страница кэшируется средствами PHP
    &lt;a href="http://www.php.net/outcontrol"&gt;Функции управления выводом&lt;/a&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    &lt;?
      // Получаем содержимое буфера
      $buffer = ob_get_contents();

      // Останов буферирования и вывод буфера
      ob_end_flush();

      // Сохранение кэш-файла с контентом
      $fp = fopen('./cache/2.cache', 'w');
      fwrite($fp, $buffer);
      fclose($fp);
    ?&gt;</pre>

      <p>Сначала вышеописанный скрипт проверяет наличие существования версии
        странички в кэше, и, если она имеется, скрипт читает и выводит её. В
        противном случае, он использует буферизацию вывода для создания версии
        страницы в кэше. Она сохраняется как файл, после использования
        ob_end_flush() для отображения страницы пользователю.</p>
      <p>Файл 2.cache содержит точную копию <em>HTML</em>, которую предоставляет скрипт:</p>
      <pre class="code">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
   &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
   &lt;head&gt;
   &lt;title&gt;Кэшированная страница&lt;/title&gt;
   &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
   &lt;/head&gt;
   &lt;body&gt;
    Эта страница кэшируется средствами PHP
   &lt;a href="http://www.php.net/outcontrol"&gt;Функции управления выводом&lt;/a&gt;
   &lt;/body&gt;
   &lt;/html&gt;</pre>

      <h3>Блочная буферизация</h3>
      <p>Упрощённый подход кэширует выводимый буфер как одну страницу. Однако
        этот подход лишает вас реальных возможностей, предоставляемых функциями
        управления выводом <em>PHP</em>, улучшающих производительность вашего
        сайта методом соответственно различающихся сроков жизни вашего
        контента.</p>
      <p>Вне всякого сомнения, некоторые части отправляемой вами посетителю
        страницы изменяются очень редко, например, такие как шапку, меню и нижний
        колонтитул. Однако другие части, типа таблиц, содержащих обсуждения в
        форуме, могут изменяться довольно часто. Буферизация вывода может
        использоваться к кэшированию разделов страницы в отдельных файлах, затем
        создавать из них страницу – решение, устраняющее необходимость повторных
        запросов к базе данных, циклов while и т.д. Вы можете назначать каждому блоку страницы
        дату истечения срока, после которой пересоздаётся кэш-файл, или кроме
        того, вы можете включить в ваше приложение механизм, который будет удалять
        кэш-файл каждый раз, когда сохранённый в нём контент изменён.</p>
      <p>Вот пример, демонстрирующий этот принцип:</p>

      <h5>Пример 3. Файл: 3.php</h5>
      <pre class="code">&lt;?
    /* Запись кэш-файла
    * @param string contents - содержание буфера
    * @param string filename - имя файла, используемое при создании кэш-файла
    * @return void
    */
    function writeCache($content, $filename) {
      $fp = fopen('./cache/' . $filename, 'w');
      fwrite($fp, $content);
      fclose($fp);
    }

    /* Проверка кэш-файлов
    * @param string filename - имя проверяемого кэш-файла
    * @param int expiry - максимальный "возраст" файла в секундах
    * @return mixed содержимое кэша или false
    */
    function readCache($filename, $expiry) {
      if (file_exists('./cache/' . $filename)) {
        if ((time() - $expiry) &gt; filemtime('./cache/' . $filename))
          return FALSE;
        $cache = file('./cache/' . $filename);
        return implode('', $cache);
      }
      return FALSE;
    }
    ?&gt;</pre>

      <p>Первые две определённые нами функции, <strong>writeCache</strong> и
        <strong>readCache</strong>, используются соответственно для создания
        кэш-файлов и проверки их существования. Функция
        <strong>writeCache</strong> получает данные для кэширования в первом
        аргументе, и имя файла, используемое при создании кэш-файла. Функция
        <strong>readCache</strong> получает имя кэш-файла в первом параметре,
        вместе со временем в секундах, после которого кэш-файл должен считаться
        устаревшим. Если она сочтёт кэш-файл допустимым, скрипт вернёт его
        содержимое, в противном случае он вернёт <strong>FALSE</strong>, чтобы
        показать, что-либо кэш-файла не существует, либо он устарел.
      </p>
      <p>В этом примере я использовал процедурный подход. Однако я не советую
        делать это на практике, поскольку это закончится очень грязным кодом
        (смотри последующие решения с лучшей альтернативой) и, вероятно, вызовет
        проблемы с блокировкой файла (например, что случится, когда кто-то
        обращается к кэшу в момент его обновления?).</p>
      <p>Давайте продолжим этот пример. После того, как запущена буферизация
        вывода, начинается обработка. Сначала скрипт вызывает
        <strong>readCache</strong>, чтобы узнать, существует ли файл
        <strong>3_header.cache</strong>, он содержит шапку страницы – заголовок
        <em>HTML</em> и начало тела. Мы используем функцию date() чтобы
        вывести время, когда страница фактически была сгенерирована, таким образом
        вы увидите различные кэш-файлы в работе, когда страница будет
        отображена.
      </p>

      <h5>Пример 4. Файл: 3.php</h5>
      <pre class="code">&lt;?
      // Начинаем буферизацию вывода
      ob_start();

      // Обработка шапки
      if (!$header = readCache('3_header.cache', 604800)) {
        // Вывод шапки
    ?&gt;

    &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
    &lt;title&gt;Страница, кэшированная поблочно&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
    Время создания шапки: &amp;lt;?=date('H:i:s'); ?&gt; &lt;br /&gt;
    &lt;?
        $header = ob_get_contents();
        ob_clean();
        writeCache($header,'3_header.cache');
      }
    ?&gt;</pre>
      <p>Что же случается когда кэш-файл не найден? Выводится некоторый контент
        и присваивается переменной при помощи ob_get_contents(),
        после чего буфер очищается функцией ob_clean().
        Это позволяет нам перехватывать вывод по
        частям и сопоставлять их с индивидуальными кэш-файлами при помощи
        <strong>writeCache</strong>. Заголовок страницы теперь хранится как файл,
        который может быть использован без нашего вмешательства в пересборку
        страницы. Давайте вернёмся на секунду к началу условного оператора. Когда
        мы вызывали <strong>readCache</strong>, мы передали ей время жизни кэша в
        604800 секунд (одна неделя), <strong>readCache</strong> использует время
        модификации кэш-файла, чтобы определить, является ли кэш-файл всё ещё
        допустимым.
      </p>
      <p>Для содержимого (тела) страницы мы по прежнему будем использовать тот
        же процесс. Однако на сей раз при вызове <strong>readCache</strong> мы
        будем использовать время жизни кэша в пять секунд, кэш-файл будет
        модифицироваться каждый раз, когда он «старше» 5 секунд:</p>

      <h5>Пример 5. Файл: 3.php</h5>
      <pre class="code">&lt;?
    // Обработка тела страницы
    if (!$body = readCache('3_body.cache', 5)) {
      echo 'Время создания тела: ' . date('H:i:s') . '&lt;br /&gt;';
      $body = ob_get_contents();
      ob_clean();
      writeCache($body, '3_body.cache');
    }
    ?&gt;</pre>

      <p>Нижний колонтитул эффективно изменять так же, как заголовок. После
        этого буферизация вывода останавливается и отображается содержимое трёх
        переменных, содержащих данные страницы:</p>
      <h5>Пример 6. Файл: 3.php (окончание)</h5>
      <pre class="code">&lt;?
    // Обработка нижнего колонтитула страницы
      if (!$footer = readCache('3_footer.cache', 604800)) {
    ?&gt;

    Время создания нижнего колонтитула: &amp;lt;?=date('H:i:s'); ?&gt; &lt;br /&gt;
    &lt;/body&gt;
    &lt;/html&gt;
    &lt;?
        $footer = ob_get_contents();
        ob_clean();
        writeCache($footer, '3_footer.cache');
      }
      // останавливаем буферизацию
      ob_end_clean();

      // Выводим содержимое страницы
      echo $header . $body . $footer;
    ?&gt;</pre>

      <p>Заголовок и нижний колонтитул обновляются еженедельно, в время как тело
        модифицируется, когда оно старее 5 секунд.</p>
      <p>Блок-схема на рисунке суммирует методологию блочной буферизации.</p>
      <figure class="image">
        <img class="image__img" alt="Блок-схема блочной буферизации вывода" src="../../img/lectures/php12_pic1.gif"
          width="608px" height="383px">
        <p>Блок-схема блочной буферизации вывода</p>
      </figure>

      <h3>Вложенные буферы</h3>
      <p>Вы можете вкладывать один буфер в другой фактически до
        бесконечности, просто вызвав <strong>ob_start()</strong> неоднократно. Это
        может быть полезным, если у вас имеется множество операций, использующих
        буфер вывода, например, одни перехватывают сообщения <em>PHP</em> об
        ошибках, другие имеют дело с кэшированием. Вы должны удостовериться, что
        <strong>ob_end_flush()</strong> или
        <strong>ob_end_clean()</strong> вызываются
        каждый раз, когда используется <strong>ob_start()</strong>.
      </p>

      <h2>Как мне управлять кэшированием на стороне клиента средствами PHP?</h2>
      <p>Пришло время посмотреть на механизм, который позволит нам
        контролировать кеш на стороне клиента средствами <em>PHP</em>. Этот подход
        будет работать только если вы используете <em>PHP</em> в связке с сервером
        <em>Apache</em>, поскольку мы будем использовать функцию getallheaders(), чтобы
        получить заголовки, передаваемые браузером.
        Эта функция работает только в <em>Apache</em>.
      </p>
      <p><em>Новые имена функций</em></p>
      <p>Если вы используете <em>PHP</em> 4.3.0 с <em>Apache</em>,
        HTTP-заголовки доступны функцией <em>apache_request_headers() и apache_response_headers(). Функция getallheaders()
          стала псевдонимом для новой функции apache_request_headers(). </em>
      </p>
      <p>Механизмом
        для работы с кэшем web-браузера вновь является
        <em>HTTP</em>. Множество заголовков вовлечёны в инструктирование
        web-браузеров и прокси-серверов независимо кэшировать страницу, ситуация
        осложняется тем фактом, что некоторые из них доступны только с
        <em>HTTP</em> 1.1.
      </p>
      <p><em>Проверка HTTP-заголовков в вашем браузере</em></p>
      <p><em>Простым но очень удобным инструментом для проверки заголовков
          запросов и откликов является <em>LiveHttpHeaders</em> – аддон к браузеру
          <em>Mozilla</em>. Необходимо точно знать, какие заголовки посылает ваш
          скрипт, особенно когда вы имеете дело с заголовками кэширования
          <em>HTTP</em>.</em></p>
      <p>Для простоты мы рассмотрим только заголовки кэширования HTTP 1.0, а
        именно <strong>Expires</strong>, <strong>Last-Modified</strong> и
        <strong>If-Modified-Since</strong>, а также статус-код <strong>HTTP 304
          (Not Modified)</strong>.
      </p>
      <p>Другие заголовки, доступные с <em>HTTP</em> 1.1, например
        <strong>Cache-Control</strong> и <strong>ETag</strong>, предназначены для
        обеспечения расширенного механизма, который может использоваться совместно
        с состоянием web-сессии, иными словами, версия данной страницы,
        отображаемой неавторизованному посетителю, может значительно отличаться от
        отображаемой авторизованному пользователю. Заголовки <em>HTTP</em> 1.1
        изначально добавлялись для того, чтобы позволить кэшировать такие
        страницы.
      </p>
      <h3>Истечение срока жизни страницы</h3>
      <p>Самым простым в использовании заголовком является заголовок
        <strong>Expire</strong>, который устанавливает дату (возможно, будущую),
        когда страница устареет. До этого момента web-браузеру разрешается
        использовать кэшированную версию страницы.
      </p>

      <h5>Пример 7. 6.php</h5>
      <pre class="code">&lt;?
    /**
    * Посылает заголовок Expires HTTP 1.0.
    * @param int $expires - количество секунд до времени истечения срока жизни
    */
    function setExpires($expires){
      header('Expires: ' .
    &nbsp;&nbsp;&nbsp;&nbsp;gmdate('D, d M Y H:i:s', time() + $expires) . 'GMT');
    }

    // Устанавливаем заголовок времени истечения срока жизни Expires
    setExpires(10);

    // Отображаем
    echo 'Эта страница самоуничтожится через 10 секунд&amp;lt;br /&amp;gt;';
    echo 'Сейчас ' . gmdate('H:i:s') . ' GMT&amp;lt;br /&amp;gt;';
    echo '&amp;lt;a href="' . $_SERVER['PHP_SELF'] .
    &nbsp;&nbsp;&nbsp;&nbsp;'"&amp;gt;Посмотреть вновь &amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;';
    ?&gt;</pre>
      <p>Функция <strong>setExpires</strong> отправляет заголовок <em>HTTP</em>
        <strong>Expires</strong> с будущим временем, заданном в секундах.
        Вышеприведённый пример показывает текущее время по Гринвичу и выводит
        ссылку, которая вам позволяет перейти на страницу вновь. Используя кнопку
        Refresh вашего браузера, вы можете сообщить браузеру о желании обновить
        кэш. Используя ссылку, вы увидите, что время изменяется только раз в 10
        секунд.
      </p>
      <p><em>Даты и время в HTTP</em></p>
      <p><em>Даты в HTTP всегда вычисляются относительного меридиана времени
          Гринвича (GMT). Функция PHP gmdate() точно такая же функция, как
          date(), за исключением того,
          что она автоматически компенсирует время по Гринвичу, основанное на
          системных часах и настройках региона вашего сервера.</em></p>
      <p>Когда браузер сталкивается с заголовком <strong>Expires</strong>, он
        кэширует страницу. Все последующие запросы страницы, сделанные до
        указанного времени истечения срока жизни, используют версию страницы из
        кэша, никаких запросов к web-серверу при этом не происходит.</p>
      <p>Заголовок <strong>Expires</strong> преимущественно прост в реализации,
        но в большинстве случаев, если вы не высокоорганизованный человек, вы не
        можете знать точно, когда данная страница вашего сайта обновлена.
        Поскольку браузер войдёт в контакт с сервером только после того, как
        страница устареет, нет ни одного способа сообщить браузеру, что страница,
        находящаяся в его кэше, устарела. Вы также теряете некоторую часть трафика
        к вашему web-сайту, поскольку браузер не обращается к серверу при запросе
        страницы из кэша.</p>

      <h3>Время изменения страницы</h3>
      <p>Более практично использовать заголовки <strong>Last-Modified</strong> и
        <strong>If-Modified-Since</strong>, доступные в <em>HTTP</em> 1.0.
        Технически он известно как выполнение условного GET-запроса, вы
        возвращаете любой контент, основываясь на условии пришедшего заголовка
        запроса <strong>If-Modified-Since</strong>.
      </p>
      <p>При использовании этого метода вы должны отправлять заголовок
        <strong>Last-Modified</strong> каждый раз, когда обращаются к вашему
        PHP-скрипту. При следующем запросе страницы браузером, он отправит
        заголовок <strong>If-Modified-Since</strong>, содержащий время, по
        которому ваш скрипт может определить, обновлялась ли страница со времени
        последнего запроса. Если это не так, ваш скрипт посылает код статуса
        <strong>HTTP 304</strong>, чтобы указать, что страница не изменялась, не
        выводя при этом содержимого страницы.
      </p>
      <p>Устанавливаем время модификации кэш-файла этой строкой:</p>
      <pre class="code">$lastModified = filemtime($cache_file);</pre>
      <p>Затем, используя время модификации кэш-файла, мы посылаем заголовок
        <strong>Last-Modified</strong>. Нам нужно посылать её для каждой
        предоставляемой страницы, чтобы вынудить браузер посылать нам заголовок
        <strong>If-Modified-Since</strong> с каждым запросом.
      </p>
      <pre class="code">// Выдаём заголовок HTTP Last-Modified
    header('Last-Modified: ' .
    &nbsp;&nbsp;&nbsp;&nbsp;gmdate('D, d M Y H:i:s', $lastModified) . ' GMT');</pre>
      <p>Использование функции getallheaders()
        обеспечивает нам получение от <em>PHP</em>
        всех входящих заголовков в виде массива. Затем мы должны проверить, что
        заголовок <strong>If-Modified-Since</strong> действительно существует,
        если он есть, мы должны обработать специальный случай старых версий
        <em>Mozilla</em> (ниже 6й версии), который добавлял в конец дополнительное поле к заголовку
        <strong>If-Modified-Since</strong>. Используя функцию <em>PHP</em>
        strtotime(), мы получаем
        таймштамп даты, переданной нам браузером. Если такого заголовка нет, мы
        присваиваем таймштампу ноль, вынуждая таким образом <em>PHP</em> отдать
        посетителю последнюю версию страницы.
      </p>
      <pre class="code">&lt;?
    // Получаем заголовки запроса клиента - только для Apache
    $request = getallheaders();

    if (isset($request['If-Modified-Since'])) {
      // Разделяем If-Modified-Since (Netscape &amp;lt; v6 отдаёт их неправильно)
       $modifiedSince = explode(';', $request['If-Modified-Since']);

       // Преобразуем запрос клиента If-Modified-Since в таймштамп
       $modifiedSince = strtotime($modifiedSince[0]);
    } else {
      // Устанавливаем время модификации в ноль
       $modifiedSince = 0;
    }
    ?&gt;</pre>
      <p>Наконец, мы проверяем, был ли модифицирован кэш с тех пор как
        посетитель получал эту страницу в последний раз. Если это не так, мы
        просто посылаем в заголовке отклик <strong>Not Modified</strong> и
        прекращаем выполнение скрипта, не нагружая канал передачи данных и экономя
        процессорное время, инструктируя браузер отобразить кэшированную версию
        страницы.</p>
      <pre class="code">&lt;?
    // Сравниваем время последней модификации контента с кэшем клиента
    if ($lastModified &lt;= $modifiedSince) {
    &nbsp;&nbsp;&nbsp;&nbsp;// Разгружаем канал передачи данных!
    &nbsp;&nbsp;&nbsp;&nbsp;header('HTTP/1.1 304 Not Modified');
    &nbsp;&nbsp;&nbsp;&nbsp;exit();
    }
    ?&gt;</pre>
      <p>И в заключение готовый кусок кода, позволяющий кешировать все статические ваши страницы.</p>
      <p>
        <strong>index.php</strong> - через него загружаются все файлы с сервера.
        Настройка сделана с помощью <a href="php14.php">.htaccess</a>
      </p>
      <pre class="code">&lt;?
    $url&nbsp;&nbsp;&nbsp;&nbsp;= $_SERVER['REQUEST_URI'];
    if($url==""||$url=="/")
       $url="index.htm" ;
    else $url=substr($url, 1);

    if ( !file_exists( $url ) )
    &nbsp;&nbsp;&nbsp;&nbsp;{ header("HTTP/1.0 404 Not Found"); exit();}

    // Получаем время последней модификации кэш-файла
    $lastModified = max(filemtime($url),filemtime('index.php'));
    $slastModified = gmdate('D, d M Y H:i:s', $lastModified) . ' GMT';
    // Выдаём заголовок HTTP Last-Modified
    header('Last-Modified: ' . $slastModified );
    // Получаем заголовки запроса клиента - только для Apache
    $headers = getallheaders();
    if (isset($headers['If-Modified-Since'])) {
       // Разделяем If-Modified-Since (Netscape &lt; v6 отдаёт их неправильно)
       $modifiedSince = explode(';', $headers['If-Modified-Since']);
       // Преобразуем запрос клиента If-Modified-Since в таймштамп
       $modifiedSince = strtotime($modifiedSince[0]);
       // Сравниваем время последней модификации контента с кэшем клиента
       if ($lastModified &lt;= $modifiedSince)
    &nbsp;&nbsp;&nbsp;&nbsp;// Разгружаем канал передачи данных!
    &nbsp;&nbsp;&nbsp;&nbsp;{ header('HTTP/1.1 304 Not Modified'); exit(); }
       }
    echo "&lt;DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"&gt;\n&lt;HTML&gt;\n";
    echo "&lt;HEAD&gt;\n";
    echo "&lt;META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=utf-8\"&gt;\n";
    echo "&lt;meta http-equiv=\"Last-Modified\" content=\"".$slastModified."\"&amp;gt;\n";
    ?&gt;</pre>
      <p>Если вы объедините подход времени последнего изменения со значением
        времени, являющимся уже доступным в вашем приложении (например, время
        самой последней новостной статьи, или время устаревания из системы
        серверного кэширования, которое мы видели в последнем решении), вы сможете
        воспользоваться преимуществами кэша web-браузера и разгрузите канал
        передачи данных, по возможности сэкономив информационный трафик с вашего
        сайта и улучшив его производительность.</p>
      <p>Будьте осторожны при тестировании любого кэширования, выполненного в
        таком стиле, если вы сделаете это неправильно, вы можете заставить ваших
        посетителей всегда иметь устаревшие копии вашего сайта.</p>


      <h2>Кэширование ваших страниц в 5 шагов</h2>
      <p>Кэширование ваших страниц может
        оказаться красивым и полезным механизмом, особенно, если они
        генерируются средствами PHP и делают множество SQL запросов. Как только
        вы примените кэширование, ваш сервер тут же снизит нагрузку и перестанет
        съедать много памяти на генерацию страниц - он просто будет загружать их
        из КЭШа. Я покажу вам, как PHP может кэшировать страницы и, в
        дальнейшем, вы сможете тратить на это минут 5.</p>

      <p>Расмотрим технологию кэширования пошагам:</p>
      <ol>
        <li>В домашней директории создаем файлы <strong>.htaccess</strong>,
          <strong>start_cache.php</strong>, <strong>end_cache.php</strong>, а
          также папку с названием <strong>cache_files</strong>.<br>
        </li>
        <li>Папке <strong>cache_files</strong> необходимо проставить атрибуты <strong>777</strong>.<br> <br></li>
        <li>Внутри <strong>.htaccess</strong> файла пропишите следующие строки:

          <pre class="code">php_value auto_prepend_file
        /home/username/public_html/start_cache.php
    php_value auto_append_file
        /home/username/public_html/end_cache.php
    </pre>
          Строку <em>/home/username/public_html/</em> необходимо заменить на путь к вашей домашней директории.<br>
          <br>
        </li>

        <li>В скрипт <strong>start_cache.php</strong> помещаем следующий код:
          <pre class="code">&lt;?php
    // раздел настроек, которые вы можете менять
    $settings_cachedir = '/home/username/public_html/cache_files/';
    $settings_cachetime = 3600; //время жизни кэша (1 час)

    // код
    $thispage = 'http://' .
      $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
    $cachelink = $settings_cachedir.md5($thispage).".html";
    if (file_exists($cachelink)) {
        $cachelink_time = filemtime($cachelink);

        if ((time() - $settings_cachetime) &lt; $cachelink_time) {
            readfile($cachelink);die();
        }
    }

    ob_start();
    ?&gt;
    </pre>
          Не забывайте исправлять путь <em>/home/username/public_html/</em> на путь к вашей домашней директории.<br>
          <br>
        </li>

        <li>А следующий код поместите в скрипт <strong>end_cache.php</strong>:
          <pre class="code">&lt;?php
    $fp = fopen($cachelink, 'w');
    fwrite($fp, ob_get_contents());
    fclose($fp);
    ob_end_flush();
    ?&gt;
    </pre>
        </li>
      </ol>

      <p>Все ваши страницы будут кэшироваться на 3600 секунд = 1 час. Этот параметр вы легко можете поменять в скрипте
        <strong>
          start_cache.php</strong>. Кэш страниц будет сохранен в папке <strong>
          cache_files</strong>.
      </p>

      <p>Совершенно очевидно, что в данном случае атрибуты <strong>777</strong>
        являются определенным нарушением безопасности. В связи с чем, рекомендую
        вынести папку <strong>cahce_files</strong> за пределы <strong>
          public_html</strong>, например, поместить ее на один уровень выше. Это
        закроет доступ к находящимся в ней файлам пользователей вашего сайта, но
        никак не повлияет на работоспособность системы.</p>
      <p>Также, у данного метода есть еще один серьезный недостаток: автор
        статьи складывает весь кэш в одну папку, что, при достаточном количестве
        страниц на вашем сайте, вызовет проблему, например, в системах Unix
        наблюдается достаточное замедление работоспособности при наличие в папке
        более чем 1000 файлов. В связи с чем, в алгоритм необходимо внести ряд
        изменений и раскладывать файлы по отдельным подпапкам внутри папки
        <strong>cache_files</strong>. Например, используя для этого первые 3-4
        символа md5 КЭШа.
      </p>
      <p>Для динамических ресурсов вполне возможно выбрать время кэширования в
        несколько (5-10) секунд или 1-2 минуты, что уже значительно снизит
        нагрузку на сервер, но не нанесет вреда интерактивности сайта.</p>

      <p>Для страниц, для которых особо важна интерактивность, можно ввести
        исключения в <strong><a href="php14.php">.htaccess</a></strong>, что позволит именно им
        постоянно изменяться, а для остальных страниц можно применять кэширование.</p>

      <h2>Регенерация содержания на лету</h2>

      <p>Динамически созданные, но статически обслуживаемые страницы,
        т.е. страницы которые должны передаваться как чисто статические
        (считываемые из файловой системы и затем передаваемые по запросу),
        однако они должны быть динамически сгенерированны веб-сервером если они отсутствуют в файловой системе.
        Таким образом вы можете иметь страницы сгенерированные PHP которые являются статически обслуживаемыми
        если только кто-либо (либо планировщик) не удалит статическое содержание. В таком случае содержание обновляется.
      </p>
      <p>Это делается следующим набором директив:</p>
      <pre class="code">    RewriteCond %{REQUEST_FILENAME}   !-s
        RewriteRule ^page\.html$          page.php   [T=application/x-httpd-php,L]
    </pre>
      <p>Здесь, запрос к page.html приводит к внутреннему запуску соответствующего page.php,
        если page.html все-ещё отсутствует или имеет нулевой размер.
        Фокус здесь в том что page.php это обычный PHP скрипт который в дополнение к собственному выводу, записывает
        свой
        вывод в файл page.html.
        Запустив это один раз, сервер передает данные page.html.
        Когда вебмастер хочет обновить содержание, он просто удаляет page.html (обычно с помощью cronjob).</p>

      <h2>Проблема с кэшированием страниц у Internet Explorer.</h2>

      <p>У IE при работе с заголовком "Vary" встречается одна неприятная ошибочка, связанная с кэшированием страниц.
        Проблема решается добавлением в .htaccess следующих строк:</p>
      <pre class="code">BrowserMatch "MSIE" brokenvary=1
    BrowserMatch "Mozilla/4.[0-9]{2}" brokenvary=1
    BrowserMatch "Opera" !brokenvary
    SetEnvIf brokenvary 1 force-no-vary</pre>
      <button type="button" class="button"><a class="button__link" href="php11.html">Предыдущая лекция</a></button>
      <button type="button" class="button"><a class="button__link" href="php13.html">Следующая лекция</a></button>

    </main>

  </div>

  <script src="../../js/accessibility.js"></script>

</body>

</html>
