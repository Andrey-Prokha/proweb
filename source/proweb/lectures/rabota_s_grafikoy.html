<!DOCTYPE html>
<html class="page" lang="ru">

<head>
  <meta charset="utf-8">
  <title>Работа с графикой</title>
  <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body class="page__body">

  <section class="modal">
    <div class="modal__wrapper">
      <div class="modal__block">
        <h3 class="modal__title">Размер шрифта:</h3>
        <button type="button" class="button button--accessibility fontsize-standart"
          title="Стандартный размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-2x"
          title="Увелеченный дважды размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-4x"
          title="Увелеченный четырежды размер шрифта">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Цвет сайта:</h3>
        <button type="button" class="button button--accessibility color-whiteblack" title="Бело-черный стиль">А</button>
        <button type="button" class="button button--accessibility color-blackwhite" title="Черно-белый стиль">А</button>
        <button type="button" class="button button--accessibility color-blue" title="Сине-голубой стиль">А</button>
        <button type="button" class="button button--accessibility color-standart" title="Стандартный стиль">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Изображения:</h3>
        <button type="button" class="button button--accessibility image-off" title="Отключить изображение"><span
            class="visually-hidden">Выкл.</span></button>
        <button type="button" class="button button--accessibility image-on" title="Включить изображение"><span
            class="visually-hidden">Вкл.</span><svg class="image__svg" version="1.1" xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 350 350">
            <path
              d="M5,350h340V0H5V350z M25,330v-62.212h300V330H25z M179.509,247.494H60.491L120,171.253L179.509,247.494z   M176.443,211.061l33.683-32.323l74.654,69.05h-79.67L176.443,211.061z M325,96.574c-6.384,2.269-13.085,3.426-20,3.426  c-33.084,0-60-26.916-60-60c0-6.911,1.156-13.612,3.422-20H325V96.574z M25,20h202.516C225.845,26.479,225,33.166,225,40  c0,44.112,35.888,80,80,80c6.837,0,13.523-0.846,20-2.518v130.306h-10.767l-104.359-96.526l-45.801,43.951L120,138.748  l-85.109,109.04H25V20z" />
          </svg></button>
      </div>
    </div>
  </section>

  <button type="button" class="accessibility" title="Открыть панель доступности"><svg width="50" height="50"
      viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
      <path class="accessibility__svg"
        d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
      </path>
    </svg></button>
  <div class="page__wrapper">

    <header class="header">

      <nav class="nav">
        <ul class="nav__list">
          <li class="nav__item">
            <a class="nav__link" href="../../index.html">Главная</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../lectures.html">Лекции</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../video.html">Видео-уроки</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../practical.html">Лабораторные работы</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../tests.html">Тесты</a>
          </li>
        </ul>
      </nav>

    </header>

    <main class="content">
      <h1 class="content__title">Canvas & SVG: работаем с графикой</h1>
      <p>В HTML5 представлено два элемента для работы с web графикой: Canvas и SVG.
        Две эти технологии достаточно сильно отличаются друг от друга. Важно знать об их
        преимуществах и недостатках, чтобы выбрать наиболее подходящую для конкретной задачи технологию.
        Элемент SVG позволяет создавать векторную графику, а элемент Canvas предназначен для создания растровых
        изображений. Элемент Сanvas также используется технологией WebGL для аппаратного ускорения 3D-графики..</p>
      <h2>SVG</h2>
      <p>Масштабируемая векторная графика (Scalable Vector Graphics — SVG) является языком разметки, расширенным из XML
        для описания двухмерной векторной графики.</p>
      <p>Для создания изображения в векторной графике используются геометрические примитивы (точки, линии, кривые,
        многоугольники).
        С их помощью можно создавать масштабируемые изображения, которые не теряют в качестве при масштабировании.</p>
      <p>SVG — технология рисования с хранением объектов в памяти (Retained mode graphics). Как и HTML, SVG имеет
        объектную
        модель документа
        (DOM). DOM в SVG, как и в HTML, имеется модель событий. Это значит, что при использовании этой технологии для
        реализации интерактивных
        действий (таких как управление мышью и т.п.)
        со стороны программиста требуется меньше усилий, поскольку события привязываются непосредственно к элементам
        DOM.
      </p>
      <p>SVG имеет как обычные атрибуты, так и атрибуты представления. Ключевым моментом является то, что к атрибутам
        представления можно применять
        стили в соответствии с правилами использования стилей CSS. К примеру, для изменения цвета фигуры можно применять
        свойство fill.</p>
      <h4>Пример</h4>
      <pre class="code">
   &lt;svg xmlns"http://www.w3.org/2000/svg" version="1.1" width="600" height="70"&gt;
   line x1"5" y1"5" x2"500"y2"60" stroke"#b4241b" stroke-width"3"/&gt;
   &lt;/svg&gt;</pre>
      <h4>Пример</h4>
      <p>HTML:</p>
      <pre class="code">&lt;svg xmlns"http://www.w3.org/2000/svg" version="1.1" width="100" height="100"&gt;
   circle cx"50" cy"50" r"40"y2"60" stroke"#b4241b" stroke-width"3"/&gt;
   &lt;/svg&gt;</pre>
      </pre>
      <p>CSS:</p>
      <pre class="code">svg{fill:blue;}</pre>
      <h2>Canvas 2d</h2>
      <p>
        <Сanvas> — это HTML элемент, который используется для создания растровой графики при помощи JavaScript. Элемент
          <span>&lt;canvas&gt; предоставляет удобный API
            для рисования 2D графики с помощью JavaScript.
      </p>
      <p>В отличии от svg, canvas работает с растровой графикой. Это технология мгновенного рисования, она не хранит
        свои
        элементы в дереве DOM,
        следовательно нет никакого способа изменить существующий рисунок или реагировать на события.
        Это означает, что, когда потребуется новый кадр, необходимо будет отрисовать всю сцену заново.</p>

      <p>Элемент <span>&lt;canvas&gt; имеет только два атрибута — ширину и высоту. Если атрибуты высоты и ширины не
          установлены,
          то согласно спецификации html5 ширина элемента canvas будет равна
          300 пикселям, а высота 150. При изменении этих атрибутов canvas очищается.</p>
      <p>Также можно выставить размеры произвольно в CSS, но во время рендеринга изображение будет масштабироваться в
        соответствии с его размером и ориентацией.
        Это может привести к тому, что изображение будет выглядеть искаженным.</p>
      <p>Для рисования в первую очередь необходимо получить доступ к контексту, который предоставляет API для создания
        графики.
        Контекст можно получить при помощи метода getContext() элемента canvas. В качестве первого параметра необходимо
        указать тип контекста,
        который мы хотим использовать. На данный момент большинство современных браузеров поддерживает 2 типа контекста
        «2d» ( позволяет создавать 2-х мерную графику)
        и «webgl» (позволяет использовать технологию
        WebGL для создания трехмерной графики). Если указанный тип контекста не поддерживается браузером, метод
        getContext() возвращает null.</p>
      <h4>Пример</h4>
      <pre class="code">&lt;canvas id"myCanvas" width"600px"height"70px"&lt;/canvas&gt;
        const canvasdocument.getElementById('canvas');
        const contextcanvas.getContext('2d');
        context.beginPath(); context.moveTo(5, 5);
        context.lineTo(500, 60);
        context.lineWidth 3;
        context.strokeStyle'#b4241b';
        context.stroke();
      </pre>
      <br>
      <h2>WebGL</h2>
      <p>WebGL — это еще одна новая технология, которая использует элемент canvas для создания графики. WebGL позволяет
        веб-контенту использовать API,
        основанный на OpenGL ES 2.0, для визуализации трехмерной графики, но возможно работать и с двухмерной графикой.
      </p>
      <p>Для начала рисования так же, как и в предыдущем случае, необходимо получить доступ к контексту. Это делается
        при
        помощи метода getContext.
        В качестве типа контекста необходимо указать webgl либо experimental-webgl.
        Контекст, именуемый как «experimental-webgl» — это временное имя для контекста, используемое на время процесса
        разработки спецификации.</p>
      <p>WebGL работает с растровой графикой, соответственно, особенности описанные в предыдущем абзаце, применимы и к
        этой
        технологии. Но
        для WebGL характерна более высокая производительность (сравнимая с производительностью нативных приложений),
        поскольку WebGL
        использует средства аппаратного ускорения графики.</p>
      <h2>Сравнение технологий</h2>

      <p>Выбор конкретной технологии зависит от задач и целей конкретного проекта. На одном из проектов была поставлена
        задача отриcовки графиков с большим
        количеством точек (порядка 10 000 точек),
        должна была быть предусмотрена возможность масштабирования и перемещения графиков, а также перерисовка графиков
        в
        случае изменения данных на сервере. </p>
      <p>Один из самых важных параметров, который учитывался при выборе технологии, была производительность.
        Этот параметр зависит от количества объектов и площади поверхности. В общем случае, по мере увеличения числа
        объектов на экране производительность SVG падает, поскольку объекты постепенно добавляются в модель DOM, тогда
        как производительность canvas почти не изменяется. WebGL имеет очень хорошую производительность, однако не все
        современные браузеры поддерживают данную технологию, к примеру IE начал поддерживать webGL начиная только с 11
        версии.
        Поддержка WebGL на мобильных браузерах достаточно ограниченна, большинство мобильных браузеров начали
        поддерживать
        WebGL только с 2017 года. Некоторые мобильные браузеры на данный момент вообще не поддерживают данную
        технологию.
      </p>
      <p>К тому же, помимо поддержки WebGL браузером, необходима также его поддержка графическим процессором клиента.
        Некоторые браузеры могут отключить поддержку WebGL на устройствах со старыми графическими процессорами.</p>
      <p>По причине слабой поддержки технологии WebGL далее будут рассматриваться только две технологии: canvas 2d и
        svg.
      <figure class="image">
        <img class="image__img" src="../../img/lectures/grafica_pic1.png">
        <p>Рис.1 Время рендеринга(y) в зависимости от количества объектов(х).</p>
      </figure>
      <p>Так как работа с SVG требует много манипуляций с DOM эта технология не подходит для тяжелой анимации,
        к примеру для построения быстро изменяющихся детализированных графиков.</p>
      <p>Однако canvas не очень хорошо подходит для экранов с высоким разрешением. Из графика ниже видно, что по мере
        увеличения размера экрана производительность
        Canvas падает, поскольку требуется обработать больше пикселей.</p>
      <figure class="image">
        <img class="image__img" src="../../img/lectures/grafica_pic2.png">
        <p>Рис.2 Время рендеринга(y) в зависимости от высоты области рисования(х).</p>
      </figure>

      <p>Также необходимо учитывать, что при увеличении изображения, созданные при помощи canvas, сильно теряют
        качество.
        На рисунке ниже показаны линии, нарисованные при помощи svg и canvas.</p>
      <figure class="image">
        <img class="image__img" src="../../img/lectures/grafica_pic3.png">
        <p>Рис.3 Линии нарисованные при помощи SVG(сверху) и Canvas(снизу) при увеличении.</p>
      </figure>

      <p>Еще одна проблема с которой можно столкнуться при работе с canvas — ограниченные возможности отслеживания
        событий
        и определения
        расположения указателя мыши на изображении. Существует встроенный API isPointInPath, который позволяет
        определить
        попадает ли указанная точка в последний
        нарисованный элемент path.*
        Существуют сторонние библиотеки, позволяющие достаточно комфортно работать с событиями.</p>
      <p>Несмотря на перечисленные выше недостатки, было принято решение использовать именно canvas,
        в первую очередь из-за его высокой производительности по сравнению с svg при отрисовке большого количества
        объектов.
      </p>
      <p>* Существует экспериментальный интерфейс Path2D, который можно использовать для создания пути, который в
        дальнейшем можно будет переиспользовать.
        К примеру этот объект можно передать в качестве первого аргумента метода isPointInPath. На данный момент эта
        технология поддерживается браузерами
        Firefox, Google Chrome и Opera.
      </p>

      <h2>Особенности работы с Canvas</h2>

      <p>При работе с сanvas в первую очередь необходимо учитывать то, что мы работаем с растровым изображением.
        В первую очередь это значит, то что при изменении размера области отрисовки (к примеру при изменении размеров
        окна)
        изображение на canvas масштабируется, что приводит к искажениям и потере качества. На рисунке ниже в первом
        случае
        css
        свойства width и height элемента canvas в два раза больше соответствующих атрибутов указанных изначально. Рядом
        изображен
        тот же график без масштабирования. Для избежания подобных проблем следует при изменении
        размеров окна выставлять необходимые значения для атрибутов width и height элемента canvas и перерисовывать
        текущую сцену с
        учетом новых размеров. </p>

      <p>С похожей проблемой можно столкнуться при работе с экранами с увеличенной плотностью пикселей. Изображения на
        canvas могут выглядеть размытыми.
        Причиной этого является разница между разрешением дисплея в физических пикселях и разрешением в логических (CSS)
        пикселях. Отношение двух этих величин
        можно получить при помощи свойства window.devicePixelRatio. К примеру при devicePixelRatio равным двум ширина
        канваса в физических пикселях в 2 раза
        больше, чем его ширина в логических пикселях (указанная в атрибуте width). То есть мы получим тот же эффект, что
        и
        в первом случае.
        Один из возможных способов решения этой проблемы: указывать значения в атрибутах canvas большее чем в стилях в
        величину devicePixelRatio. </p>
      <pre class="code">canvas.width = canvasWidth * window.devicePixelRatio;
   canvas.height  = canvasHeight * window.devicePixelRatio;
   canvas.style.width  = canvasWidth + 'px';
   canvas.style.height  = canvasHeight + 'px';
   </pre>

      <p>В этом случае при отрисовке необходимо учитывать, что такие величины, как толщина линии и размер шрифта
        уменьшаться на величину devicePixelRatio. Следовательно, при задании размера шрифта его
        необходимо умножать на devicePixelRatio, чтобы текст не казался слишком мелким на дисплеях с увеличенной
        плотностью пикселей.</p>
      <figure class="image">
        <img class="image__img" src="../../img/lectures/grafica_pic4.png">
      </figure>

      <h2>Оптимизация работы canvas</h2>

      <p>Одной из самых дорогих операций при работе с canvas является рисование. Следовательно, лучше избегать
        перерисовки
        больших изображений.</p>
      <p>Один из способов это сделать — применять элементы canvas в несколько слоев. Это позволяет перерисовывать только
        те
        части сцены, которые необходимо, а не всю сцену целиком.</p>

      <h4>Пример</h4>
      <pre class="code">
   &lt;canvas id"bg" width"640" height"480" style"position: absolute; z-index: 0"&gt;
   &lt;/canvas&gt;
   &lt;canvas id"fg" width"640" height"480" style"position: absolute; z-index: 1"&gt;
   &lt;/canvas&gt;
   </pre>

      <p>Еще один способ уменьшить время, затрачиваемое на отрисовку — это отказ от координат с плавающей запятой и
        использование целочисленных координат.
        При использовании дробных координат на элементе canvas применяется субпиксельный рендеринг.
        Это приводит к тому, что для создания эффекта сглаживания производятся дополнительные вычисления.</p>
      <p>Существует достаточно много приемов оптимизации элемента canvas.
        Их эффективность зависит от особенностей проекта и желаемого результата.</p>
      <h2>Заключение</h2>
      <p>SVG хорошо подходит для создания статических изображений, высококачественных сложных векторных документов (к
        примеру чертежей, схем) интерактивных графиков.
        Но стоит учитывать, что при возрастании количества объектов, скорость отрисовки будет сильно снижаться.
        Использование элемента canvas позволяет достаточно быстро
        отрисовывать изображения на экране, именно поэтому эта технология хорошо подходит для отображения сложных сцен и
        анимации в режиме реального времени. Canvas может
        применяться для создания различных визуальных эффектов и сложных 3D сцен.
        Но при использовании данной технологии достаточно сложно сделать изображение или график интерактивным.</p>

      <button type="button" class="button"><a class="button__link" href="php14.html">Предыдущая лекция</a></button>
      <button type="button" class="button"><a class="button__link" href="javascript.html">Следующая лекция</a></button>

    </main>

  </div>

  <script src="../../js/accessibility.js"></script>

</body>

</html>
