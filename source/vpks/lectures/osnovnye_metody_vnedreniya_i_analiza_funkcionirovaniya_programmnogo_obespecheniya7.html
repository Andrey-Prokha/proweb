<!DOCTYPE html>
<html class="page" lang="ru">

<head>
  <meta charset="utf-8">
  <title>Тестирование программного обеспечения</title>
  <link rel="shortcut icon" href="../../img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="../../css/style.css">
</head>

<body class="page__body">

  <section class="modal">
    <div class="modal__wrapper">
      <div class="modal__block">
        <h3 class="modal__title">Размер шрифта:</h3>
        <button type="button" class="button button--accessibility fontsize-standart"
          title="Стандартный размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-2x"
          title="Увелеченный дважды размер шрифта">А</button>
        <button type="button" class="button button--accessibility fontsize-4x"
          title="Увелеченный четырежды размер шрифта">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Цвет сайта:</h3>
        <button type="button" class="button button--accessibility color-whiteblack" title="Бело-черный стиль">А</button>
        <button type="button" class="button button--accessibility color-blackwhite" title="Черно-белый стиль">А</button>
        <button type="button" class="button button--accessibility color-blue" title="Сине-голубой стиль">А</button>
        <button type="button" class="button button--accessibility color-standart" title="Стандартный стиль">А</button>
      </div>
      <div class="modal__block">
        <h3 class="modal__title">Изображения:</h3>
        <button type="button" class="button button--accessibility image-off" title="Отключить изображение"><span
            class="visually-hidden">Выкл.</span></button>
        <button type="button" class="button button--accessibility image-on" title="Включить изображение"><span
            class="visually-hidden">Вкл.</span><svg class="image__svg" version="1.1" xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 350 350">
            <path
              d="M5,350h340V0H5V350z M25,330v-62.212h300V330H25z M179.509,247.494H60.491L120,171.253L179.509,247.494z   M176.443,211.061l33.683-32.323l74.654,69.05h-79.67L176.443,211.061z M325,96.574c-6.384,2.269-13.085,3.426-20,3.426  c-33.084,0-60-26.916-60-60c0-6.911,1.156-13.612,3.422-20H325V96.574z M25,20h202.516C225.845,26.479,225,33.166,225,40  c0,44.112,35.888,80,80,80c6.837,0,13.523-0.846,20-2.518v130.306h-10.767l-104.359-96.526l-45.801,43.951L120,138.748  l-85.109,109.04H25V20z" />
          </svg></button>
      </div>
    </div>
  </section>

  <button type="button" class="accessibility" title="Открыть панель доступности"><svg width="50" height="50"
      viewBox="0 0 1750 1750" xmlns="http://www.w3.org/2000/svg">
      <path class="accessibility__svg"
        d="M1664 960q-152-236-381-353 61 104 61 225 0 185-131.5 316.5t-316.5 131.5-316.5-131.5-131.5-316.5q0-121 61-225-229 117-381 353 133 205 333.5 326.5t434.5 121.5 434.5-121.5 333.5-326.5zm-720-384q0-20-14-34t-34-14q-125 0-214.5 89.5t-89.5 214.5q0 20 14 34t34 14 34-14 14-34q0-86 61-147t147-61q20 0 34-14t14-34zm848 384q0 34-20 69-140 230-376.5 368.5t-499.5 138.5-499.5-139-376.5-368q-20-35-20-69t20-69q140-229 376.5-368t499.5-139 499.5 139 376.5 368q20 35 20 69z">
      </path>
    </svg></button>

  <div class="page-wrapper">

    <header class="header">
      <nav class="nav">
        <ul class="nav__list">
          <li class="nav__item">
            <a class="nav__link" href="../../index.html">Главная</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../lectures.html">Лекции</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../video.html">Видео-уроки</a>
          </li>
          <li class="nav__item">
            <a class="nav__link" href="../practical.html">Лабораторные работы</a>
          </li>
        </uL>
      </nav>

    </header>

    <main class="content">

      <h1 class="content__title">Тестирование программного обеспечения</h1>
      <p>Любая&nbsp;программа&nbsp;может содержать в себе ошибки.&nbsp;Компилятор&nbsp;способен выявлять
        только&nbsp;синтаксические ошибки, но не способен отслеживать семантику. Большинство ошибок проявляется в ходе
        работы программы, при этом они могут возникать не всегда, а лишь при определенных условиях. Таким образом,
        успешная&nbsp;компиляция&nbsp;программы и выполнение этой программы в одних и тех же условиях не гарантируют
        отсутствие ошибок.</p>
      <p>Для выявления ошибок в программах ЖЦ разработки&nbsp;ПО&nbsp;предусматривает процесс тестирования, который
        является достаточно трудоемким и занимает больше времени, чем&nbsp;кодирование. (Г. Майерс дает оценку 1/3 для
        тестирования, при том, что&nbsp;кодированиезанимает примерно 1/6.) Тестируемое&nbsp;ПО&nbsp;обычно называют SUT
        -&nbsp;Software&nbsp;Under Test. Цель тестирования - не убедиться в безошибочной работоспособности программы, а
        наоборот - найти ошибки. Поэтому в первую&nbsp;очередь&nbsp;возникает вопрос: а что есть ошибка в программе?</p>
      <p>Заметим, что к этому моменту&nbsp;программа&nbsp;уже представляет собой выполнимый процессором набор команд,
        т.е.
        с точки зрения процессора она корректна. Даже если при каких-то условиях&nbsp;программа&nbsp;аварийно завершает
        свое выполнение или "портит" другие процессы, сразу нельзя сказать, что это ошибка в программе - возможно, так
        было задумано. Таким образом, ошибки необходимо рассматривать с точки зрения пользователя, основываясь на
        дополнительной информации, т.е. неком описании того, что должна делать&nbsp;программа&nbsp;(это же описание
        может включать в себя требование о том, чтобы&nbsp;программа&nbsp;никогда не завершалась аварийно и др.).</p>
      <figure class="image">
        <img class="image__img"
          src="../../img/lectures/osnovnye_metody_vnedreniya_i_analiza_funkcionirovaniya_programmnogo_obespecheniya7_pic_01.jpg">
        Рис. 1. V-образная модель жизненного цикла разработки ПО
      </figure>
      <p>При рассмотрении вопросов анализа программного кода порой удобнее применять ранее рассмотренную в разделе 1
        модель жизненного&nbsp;цикла. Ее часто называют V-образной из-за расположения блоков на рисунке (рис. 1).</p>
      <p>Нисходящая левая&nbsp;ветвь&nbsp;модели отражает поэтапную последовательность преобразования одних программных
        документов в другие: SYS - системных требований в SRD - требования к программному обеспечению, проектированию и
        формированию&nbsp;DDD&nbsp;- описания архитектуры системы и, наконец, разработке CODE - кода программ.
        Восходящая правая&nbsp;ветвь&nbsp;отражает процесс верификации разработанного программного обеспечения.</p>
      <p>На первом этапе путем тестирования производится модульная&nbsp;верификация&nbsp;(MV), при которой поведение
        исполняемого программного кода проверяется на соответствие его&nbsp;DDD-описанию. Это наиболее трудоемкая и
        скрупулезная часть исследования. Она часто требует написания драйверов - моделей модулей, вызывающих процедуры
        тестируемого модуля, и заглушек - моделей процедур других модулей, вызываемых из тестируемого. Часто в MV
        отдельно выделяют процесс тестирования межмодульных связей, описанных в&nbsp;DDD.</p>
      <p>На втором этапе производится комплексная&nbsp;верификация&nbsp;(CV) реализованного программного
        обеспечения&nbsp;по&nbsp;отношению к требованиям. Наконец, производится комплексная&nbsp;интеграция&nbsp;(CI) и
        проверка всей системы:&nbsp;пользователь, аппаратура и&nbsp;программное обеспечение. При грамотном процессе
        разработки уже на этапах нисходящей ветви для каждого требования определяется, на каком уровне верификации
        должна будет проводиться проверка его соблюдения.</p>
      <p>При этом следует исходить из предположения, что ошибки всегда есть. Тестирование можно считать успешным, если
        найдены ошибки, а не наоборот. В достаточно сложном&nbsp;ПО&nbsp;все ошибки могут не обнаруживаться даже после
        длительного тестирования, однако чем тщательнее ведется тестирование, тем меньше ошибок остается и тем менее
        вероятно возникновение невыявленных ошибок.</p>
      <h4>Тестовый план</h4>
      <p>Тестирование обычно проводится снизу вверх, т.е. сначала тести-руются отдельные функции, затем целые модули и
        далее проводится комплексное тестирование всей программы или комплекса программ. Для проведения тестирования
        разрабатывается тест-план (test-plan) - совокупность тестовых наборов {примеров} (test-case). В каждом тестовом
        примере производится выполнение тестируемого программного элемента SUT при заданных Input - условиях и входных
        данных и проверяются все Output - выходные данные на соответствия заданным значениям.</p>
      <p>Тестовый пример (набор) должен включать в себя как минимум:</p>
      <ul>
        <li>входы (конкретные значения всех выходных параметров, все необходимые свойства и установки окружения);</li>
        <li>действия (что надо выполнить и в какой последовательности);</li>
        <li>ожидаемый выход (конкретные величины всех возвращаемых значений, все выводы в потоки, сигналы, все
          изменяемые свойства и установки окружения).</li>
      </ul>
      <p>Кроме указанных данных удобно, если каждый тестовый пример имеет дополнительно:</p>
      <ul>
        <li>номер (уникальный номер каждого тестового примера, чтобы на него можно было ссылаться);</li>
        <li>ссылку на требование (если для тестирования используются требования, то указание ссылок на конкретные
          требования, которые проверяет данный тестовый пример, упростит локализацию ошибок и обеспечит возможность
          проверки полноты тестирования);</li>
        <li>краткое описание (что проверяет данный тестовый пример).</li>
      </ul>
      <p>Для проведения тестирования разрабатывается программа-драйвер (тест), выполняющая все тестовые примеры и
        сравнивающая выходные значения с ожидаемыми. В результате выполнения теста получается не только общий результат
        - есть или нет ошибки, но еще и список пройденных и непройденных тестовых примеров, который помогает
        локализовать ошибки в SUT.</p>
      <p>Для упрощения локализации ошибок и последующей модификации тест-плана нужно, чтобы тестовые примеры были
        независимы друг от друга, т.е. чтобы каждый последующий тестовый пример никак не использовал результаты работы
        предыдущего. Для этого необходимо провести установки всех начальных условий перед выполнением каждого тестового
        примера.</p>
      <h4>Проблема полноты тестирования</h4>
      <p>Основная проблема тестирования ПО заключается в том, что проверить программу при всех возможных условиях
        функционирования в большинстве случаев невозможно. Это происходит либо в силу ограниченности ресурсов, либо в
        силу бесконечного количества возможных условий. Например, если рассмотреть функцию умножения двух рациональных
        чисел, варьируемых от -1000 до +1000, то в интервале от минимального возможного числа до максимального
        содержится бесконечное количество чисел. Т.е. все возможные значения входов проверить нельзя. Если же учесть,
        что машина оперирует невсеми этими числами, а различает только 10 знаков после запятой (т.е. множество чисел в
        интервале дискретно, минимальное отличие двух чисел 0,0000000001), то для проверки всех комбинаций из заданного
        диапазона понадобится&nbsp;10<sup>2</sup>6&nbsp;степени
        тестовых примера, что является достаточно большим числом для такой простой функции. Если проверяются не все
        возможные комбинации входных условий, то тестирование является неполным.</p>
      <p>В основном для сложных программ тестирование является неполным, но даже неполное тестирование может выявить
        большинство ошибок, если выработать грамотную стратегию их поиска. Часто используют метод деления входных
        значений на области эквивалентности, так чтобы внутри каждой области для всех значений программа "вела себя"
        похоже. Тогда при написании тестовых примеров рассматриваются все значения на границах областей и по одному
        произвольному значению из каждой области (области определяются для каждого входного параметра).</p>
      <p>Этот подход называют методом трех точек. В нашем примере для функции умножения двух чисел можно рассмотреть
        области [-1000; 0] и [0; +1000]. Деление образовано путем выявления трех особых точек (-1000, 0 и +1000). Такие
        точки называют критическими точками, в них тестируемая функция может менять свое поведение или потенциально
        вести себя особо. Т.е. для тестирования функции методом трех точек достаточно проверить&nbsp;5 * 5 ~
        10<sup>2</sup>&nbsp;случаев
        (для каждого входа это точки -1000; 0; 1000 и, например, -500 и 500), что значительно меньше полного перебора.
        Конечно, при таком подходе возможно, что какие-то ошибки останутся, но вероятность этого будет невелика и
        зависит от выбора критических точек.</p>
      <p>Функции, выполняющие различные сравнения, могут неверно их проводить, поэтому имеет смысл проверять их работу в
        непосредственной близости к критическим точкам. Для этого берутся значения, отстоящие от критических точек на
        величину дискретизации значений. Т.е. для примера функции умножения двух чисел, кроме значений метода трех
        точек, стоит рассмотреть значения -999,9999999999; -0,0000000001; 0,0000000001 и 999,9999999999. Этот подход
        называют методом пяти точек.</p>
      <p>Иная сторона тестирования связана с типизацией переменных, при помощи которых задаются входные данные. Если для
        входных значений функции используются переменные типа float, а максимальное значение входа ограничено как +1000,
        то теоретически можно передать на вход и число +1001. Зачастую реакция функции на такое число не будет даже
        описана. Однако существуют приложения, чье поведение критично даже при передаче им входных значений, выходящих
        за пределы допустимых (например, авиационные программы, программы управления ядерными реакторами). В этом случае
        подразумевается, что программа должна вести себя корректно, т.е. не "зависнуть", не "повесить" систему, хотя
        выходное значение предсказать нельзя. Тестовые примеры, проверяющие поведение программы, в таких случаях,
        называются тестами на устойчивость (robustness). Если при тестировании методом пяти точек проверять еще и
        значения, выходящие за пределы допустимых диапазонов, то такой метод будет называться методом семи точек. В
        примере функции умножения двух чисел кроме значений -1000; -500; -999,9999999999; -0,0000000001; 0,0;
        0,0000000001; 500,0; 999,9999999999; 1000 для каждого входа следует взять, например, еще значения -1001 и
        100,0000000001.</p>
      <p>Как уже было сказано, для тестирования ПО необходимо обладать информацией о том, что оно должно делать. Это
        может
        быть либо подробное описание (требования), либо просто сам код программы (в этом случае подразумевается, что
        программа должна работать корректно, не "портить память", не завершаться аварийно, не мешать другим процессам).
        В зависимости от исходной информации о ПО различают два подхода к тестированию - тестирование по требованиям и
        тестирование по коду.</p>
      <h4>Тестирование. Метод "черного ящика"</h4>
      <p>Тестирование по требованиям или тестирование "черного ящика" подразумевает неиспользование сведений о структуре
        исходного кода. Все тестовые примеры составляются только на основе требований, т.е. мы не видим, что находится
        внутри SUT и как оно работает. Единственное, что доступно - это то, что SUT должно делать, внешние эффекты
        поведения программного обеспечения.</p>
      <p>При тестировании "черного ящика" удобно использовать методы трех, пяти или семи точек. При тестировании по
        требованиям используется понятие "покрытие" требований тестами. Тест покрывает требования, если он полностью
        проверяет выполнение каждого отдельного требования. При этом возможны как случаи, когда для проверки одного
        требования необходимо несколько тестовых примеров, так и случаи, когда достаточно одного тестового примера для
        проверки нескольких требований.</p>
      <p>Рассмотрим, например, следующее требование к функции умножения двух целых чисел.</p>
      <p>Если входное значение хотя бы одного множителя выходит за гра-ницы диапазона [15 ... 1500], то функция должна
        вернуть значение 0, в противном случае функция должна вернуть значение произведения двух множителей.</p>
      <p>Для тестирования этого требования (если быть точнее, то двух требований) необходимо проверить значения
        множителей
        как из диа-пазона [15 ... 1500], так и вне его.</p>
      <p>Тесты для проверки значений из диапазона могут выглядеть, например, следующим образом.</p>
      <p>В&nbsp;табл. 1&nbsp;представлены все комбинации двух входов, каждый из которых принимает по три различных
        значения (метод трех точек), так как диапазон [15 ... 1500] с точки зрения сложения чисел не имеет критических
        точек, кроме своих концов.</p>
      <table class="table">
        <caption>Таблица 1. Часть тест-плана</caption>
        <tbody>
          <tr class="table__row">
            <td class="table__cell">Входы</td>
            <td class="table__cell">Действия</td>
            <td class="table__cell">Ожидаемый выход</td>
            <td class="table__cell"></td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">Множитель 1</td>
            <td class="table__cell">Множитель 2</td>
            <td class="table__cell"></td>
            <td class="table__cell"></td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">15</td>
            <td class="table__cell">15</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">225</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">15</td>
            <td class="table__cell">700</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">10500 </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">15</td>
            <td class="table__cell">1500</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">22500 </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">700</td>
            <td class="table__cell">15</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">10500</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">700</td>
            <td class="table__cell">700</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">490000</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">700</td>
            <td class="table__cell">1500</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">1050000 </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">1500</td>
            <td class="table__cell">15</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">22500</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">1500</td>
            <td class="table__cell">700</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">1050000 </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">1500</td>
            <td class="table__cell">1500</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">2250000 </td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">14</td>
            <td class="table__cell">14</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">1501</td>
            <td class="table__cell">14</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">14</td>
            <td class="table__cell">1501</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">14</td>
            <td class="table__cell">700</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">700</td>
            <td class="table__cell">14</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">1501</td>
            <td class="table__cell">700</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
          <tr class="table__row">
            <td class="table__cell">700</td>
            <td class="table__cell">1501</td>
            <td class="table__cell">Вызов функции</td>
            <td class="table__cell">0</td>
          </tr>
        </tbody>
      </table>
      <p>Для проверки поведения функции за границами диапазона стоит проверить, например, значения 14 и 1501 для каждого
        входа.</p>
      <p>Необходимо отметить, что не всегда можно покрыть все требования по тем же причинам, по которым невозможно
        добиться полноты тестирования, поэтому не всегда возможно доказать правильность работы программы. Кроме того,
        некоторые требования могут быть так сформулированы, что их нельзя протестировать. Например, требования могут
        касаться алгоритмов работы (а алгоритмы не видны при тестировании "черного ящика") или каких-нибудь внутренних
        переменных, не доступных извне. Некоторые требования вообще могут оказаться некорректными при тестировании, хотя
        могли быть интуитивно понятны при разработке, например требование "программа должна иметь дружественный
        интерфейс" протестировать невозможно. Для исключения таких ситуаций необходимо уже на этапе составления
        требований формулировать их как можно более конкретно и однозначно.</p>
      <p>Метод тестирования "черного ящика" выявляет все несоответствия между требованиями к ПО и поведением самого ПО.
      </p>
      <h4>Тестирование. Метод "белого ящика"</h4>
      <p>Тестирование по коду или тестирование "белого ящика" основывается на проверке кода SUT, когда в ходе выполнения
        SUT проверяется выполнение каждого блока кода. При тестировании "белого ящика" основная задача - это выполнение
        всего кода для проверки работоспособности всех его ветвей. При этом ставится задача покрытия кода тестами и
        рассматриваются разные уровни покрытия. Один из уровней покрытия (покрытие операторов) - это выполнение всех
        операторов, т.е. при выполнении всех тестовых примеров в итоге должны выполниться все операторы (не в каждом
        тестовом примере, а по результатам выполнения всех тестовых примеров).</p>
      <p>Например, для написанного ниже фрагмента программы, где A, B и C рассматриваются как входные значения:</p>

      <pre class="code">X = 0;
  if ((A&lt;=B) || (A&gt;C)) X = 5;</pre>

      <p>достаточно одного тестового примера (ТП1: A=1, B=2, C=3). В этом случае выполнятся все операторы. Но если
        программист допустил ошибку и неверно написал условие, например так:</p>

      <pre class="code">if ((A&lt;=B) || (A&gt;B)) X = 5;</pre>

      <p>то тогда код будет работать неверно (переменной&nbsp;X&nbsp;всегда будет присваиваться значение 5), хотя
        показанный выше тестовый пример приведет к выполнению всех операторов и не выявит ошибки.</p>
      <p>Для выявления таких ошибок требуется выполнить другой уровень покрытия - по условиям.</p>
      <p>Покрытие по условиям требует проверок всех условий на TRUE/FALSE, т.е. каждое условие в ходе тестирования
        должно
        проверяться на оба возможных значения. Для покрытия по условиям приведенного примера кода необходимо уже два
        тестовых примера:</p>
      <p>ТП1: A=1, B=2, C=3;</p>
      <p>ТП2: A=3, B=2, C=3.</p>
      <p>Эти тестовые примеры позволяют найти ошибку.</p>
      <p>Не все блоки кода всегда удается покрыть тестами. Это может быть связано с защитным программированием (когда
        входные значения функции проверяются на корректность, но передаются ей только корректные данные, так как
        передающая функция тоже проверяет их корректность); операторами выхода (закрывающая скобка "}" после
        оператора&nbsp;exit); мертвым кодом (код, который заведомо никогда не выполняется).</p>
      <p>Проверка таких блоков кода и анализ их "безопасности" может происходить без выполнения самого кода, в этом
        случае
        группа экспертов читает и анализирует программный код, делая выводы о существовании или несуществовании ошибок.
        Результаты подобного анализа могут установить причины появления непокрытого кода.</p>
      <p>Одной из причин может быть несовершенство тест-плана. Другой - пробелы в требованиях. И в том и в другом случае
        сам тестируемый код может не требовать изменений, но должны быть дописаны новые требования или изменены уже
        существующие и/или расширен тест-план. В обоих случаях процесс верификации повторяется.</p>
      <h4>Заглушки</h4>
      <p>Часто возникает необходимость тестировать модули, использующие процедуры других модулей, которые могут влиять
        на
        результат тестирования или значительно усложнять его получение. Допустим, имеется функция climatControl,
        обрабатывающая информацию с датчика температуры и управляющая нагревателем. Значение температуры она получает
        при помощи функции getTemperature, которая в свою очередь опрашивает температурный датчик. Пусть имеется
        следующее требование: "Если температура становится ниже 23 &deg;C, то функция climatControl должна включить
        нагреватель". Для тестирования этого требования необходимо передать функции некое значение температуры, меньшее
        23, допустим 20. Но эта величина не является входным значением функции climatControl, она задается возвращаемым
        значением функции getTemperature. Один из путей - "заставить" функцию getTemperature возвратить нужное значение,
        например подключив реальный датчик температуры и охладив его до 20&deg;С. Но при этом нет гарантии, что датчик и
        сама функция getTemperature работает правильно. А что если она возвращает значение температуры в фаренгейтах
        (20&deg;С равно 68&deg;F, т.е. функция вернет 68 вместо ожидаемых 20)? Это приведет к тому, что функция
        climatControl не включит нагреватель, даже если не содержит в себе ошибок.</p>
      <p>В таких ситуациях реальная функция getTemperature заменяется новой функцией, которая разрабатывается специально
        для конкретного (конкретных) тестового примера, и выполняет только то, что необходимо для теста, возвращая
        нужное значение. Т.е. в данном примере функция getTemperature заменяется на функцию, которая не будет опрашивать
        датчик, а сразу вернет значение 20. Функции или программы, которыми заменяются используемые при тестировании SUT
        функции и программы, называют заглушками.</p>
      <p>Стоит отметить, что если SUT использует какие-либо функции, которые не заменяются заглушками в ходе
        тестирования,
        то такие функции также должны быть предварительно протестированы. Это приводит к так называемому "восходящему"
        тестированию. Что, в свою очередь, предполагает такую же последовательность реализации модулей системы. Чаще как
        раз подобные getTemperature процедуры реализуются в последний момент, так как зависят от периферийного
        оборудования, которое не изготавливается, а закупается или характеристики которого специально подгоняются под
        условия эксплуатации системы. В этих случаях написание моделей (заглушек) программ неизбежно.</p>
      <h4>Процесс тестирования</h4>
      <p>Как уже говорилось, тест состоит из набора тестовых примеров. Перед написанием теста необходимо подготовить
        сценарий каждого тестового примера. Такие сценарии описываются в тест-плане. Тест-план представляет собой
        документ, последовательно определяющий всю совокупность тест-примеров с указанием конкретных значений всех
        входных данных, действий, а также ожидаемых значений выход-ных данных (см. выше про то, что включает в себя
        тестовый пример).</p>
      <p>В тест-плане отражается основная логика тестирования, а сам тест (набор тестовых примеров) является реализацией
        тест-плана. Вполне возможно построить универсальный тест-драйвер, который будет использовать в качестве входных
        данных тест-план, создавать на его основе все необходимые условия для каждого тестового примера и выполнять
        заданные сценарии, сравнивая реальные выходные значения с ожидаемыми. Этот подход часто применяется для
        автоматизации процесса тестирования.</p>
      <p>Если в тест-плане для каждого тестового примера указываются ссылки на тестируемые им требования, то можно
        говорить о трассировке или о соответствии тестового примера тест-плана требованию. Аналогично при кодировании
        теста для каждого тест-примера удобно указывать ссылку на номер его описания в тест-плане.</p>
      <p>Такая трассировка позволит при выявлении ошибки каким-либо тестовым примером определить, перейдя к тест-плану,
        при каких условиях проявилась ошибка, и далее, перейдя к требованиям, выяснить, какие требования нарушены. Так
        как в ходе разработки документация может меняться, то при трассировке необходимо сохранять соответствие версий
        трассируемых документов. Это, в свою очередь, позво-ляет определять область влияния внесенных изменений,
        например определить, какие тесты должны быть модифицированы или перепроверены при изменении части требований к
        системе.</p>
      <p>Результатом выполнения теста является отчет о прогоне теста, в котором отражается, сколько всего было выполнено
        тестовых примеров, сколько ошибок найдено, какие тестовые примеры выявили ошибки. Удобно помещать в отчет о
        прогоне теста ожидаемые и ре-альные значения всех выходных данных после выполнения каждого тестового примера,
        чтобы в случае выявления ошибки можно было их сравнить.</p>
      <h4>Пример верификации</h4>
      <h5>Третий этап работы</h5>
      <p>Тестирование программной реализации</p>
      <p><strong>Соображения</strong></p>
      <p>Общие требования к тест-плану состоят в определении входных воздействий на программу достаточных для контроля
        всех требований по проверке функций программной реализации как "черного ящика" (полнота покрытия требований).
        Дополнительно желательно определить входные воздействия, обеспечивающие выполнение всех ветвей программной
        реализации (программа проверяется как "белый ящик"). Часто удобно представлять тест-план в виде таблицы.</p>
      <p><strong>Выводы</strong></p>
      <p>Далее приведен неполный пример тест-плана (табл. 2).</p>
      <div>
        <table class="table">
          <caption>Таблица 2. Пример тест-плана</caption>
          <tbody>
            <tr class="table__row">
              <td class="table__cell">ВХОД</td>
              <td class="table__cell">ВЫХОД</td>
              <td class="table__cell">Проверяемое ТРЕБОВАНИЕ</td>
              <td class="table__cell">Комментарии</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"ABCD EFG,HIJ."</td>
              <td class="table__cell">"BCAD FGE,IJH."</td>
              <td class="table__cell">4.1.2</td>
              <td class="table__cell">Длина первого слова равна 4</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">" ABCD EFG,HIJ."</td>
              <td class="table__cell">" BCAD FGE,IJH."</td>
              <td class="table__cell">4.1.1; 4.1.2</td>
              <td class="table__cell">Ведущие пробелы; длина первого слова равна 4</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">" ..,,."</td>
              <td class="table__cell">" ..,,."</td>
              <td class="table__cell">4.1.3</td>
              <td class="table__cell">Строка состоит из одних разделителей</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"ABCDE FG,HIJ."</td>
              <td class="table__cell">"BCAED GF,IJH."</td>
              <td class="table__cell">4.1.2</td>
              <td class="table__cell">Длина первого слова равна 5; длина второго слова равна 2</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"1234567890.........2,,,,,,,,,8"</td>
              <td class="table__cell">"2315648970.........2,,,,,,,,,8"</td>
              <td class="table__cell">4.1; 4.1.2; 4.4</td>
              <td class="table__cell">Длина первого слова равна 10; длина остальных слов равна 1; общая длина строки 80
                символов</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"1234567890.........2,,,,,,,,,8,,"</td>
              <td class="table__cell">Сообщение "Ошибка во входной строке"</td>
              <td class="table__cell">4.3.3</td>
              <td class="table__cell">Длина строки больше 80 символов</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"1*2"</td>
              <td class="table__cell">Сообщение "Ошибка во входной строке"</td>
              <td class="table__cell">4.3.2</td>
              <td class="table__cell">Строка содержит недопустимый символ</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">"...123"</td>
              <td class="table__cell">Сообщение "Ошибка во входной строке"</td>
              <td class="table__cell">4.3.1</td>
              <td class="table__cell">Ведущие разделители не пробелы</td>
            </tr>
            <tr class="table__row">
              <td class="table__cell">""</td>
              <td class="table__cell">Сообщение "Работа закончена"</td>
              <td class="table__cell">4.2</td>
              <td class="table__cell">Введена пустая строка</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p><strong>Замечание</strong></p>
      <p>Приведенный выше тест-план не проверяет (явно) вывод предупреждающего сообщения о вводе новой строки. Такое
        требование не было явно определено в разделе 4. Это недоработка требований по проверке функций программной
        реализации. Хороший тестировщик должен сам включить подобную проверку в свой тест-план. Дополнительные пункты
        плана явно зависят от конкретного программного кода и поэтому не приведены в данном примере.</p>
      <button type="button" class="button"><a class="button__link"
          href="osnovnye_metody_vnedreniya_i_analiza_funkcionirovaniya_programmnogo_obespecheniya6.html">Предыдущая
          лекция</a></button>
      <button type="button" class="button"><a class="button__link"
          href="osnovnye_metody_vnedreniya_i_analiza_funkcionirovaniya_programmnogo_obespecheniya8.html">Следующая
          лекция</a></button>

    </main>

  </div>

  <script src="../../js/accessibility.js"></script>

</body>

</html>
